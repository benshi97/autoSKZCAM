{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p><code>autoSKZCAM</code> is a computational framework for performing accurate yet efficient predictions of ionic surfaces.</p> <ul> <li> <p><code>autoSKZCAM</code> is highly flexible, currently supporting two popular quantum chemistry codes: MRCC and ORCA, combining an arbitrary number electrostatic and mechanical embedding ONIOM layers.</p> </li> <li> <p><code>autoSKZCAM</code> is powered by QuAcc and provides pre-made surface chemistry workflows that can be efficiently dispatched (and restarted) anywhere: locally, HPC, the cloud, or any combination thereof.</p> </li> </ul> <p></p>"},{"location":"about/changelog.html","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog.html#001","title":"[0.0.1]","text":""},{"location":"about/changelog.html#added","title":"Added","text":"<ul> <li>The initial release!</li> </ul>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2024\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"installation/install.html","title":"Installation","text":"<p><code>autoSKZCAM</code> requires python &gt;= 3.11. We recommend starting in a new python environment using miniconda:</p> <pre><code>conda create --name autoskzcam python=3.11\nconda activate autoskzcam\n</code></pre> <p>For local development of the code:</p> <ol> <li>Clone the repository</li> </ol> <pre><code>git clone https://github.com/benshi97/autoSKZCAM.git\n</code></pre> <ol> <li>Then install the package in editable mode</li> </ol> <pre><code>pip install -e .\n</code></pre> <p>where this command is run in the root directory. All dependences (i.e., QuAcc) will be automatically installed. By using the <code>-e</code> flag, the package will be installed in editable mode, meaning that changes to the code will be reflected in the installed package. Installation should only take a few minutes.</p> <p>Note: You also will need to have py-ChemShell installed to run the code. It can be downloaded for free and installation instructions can be found here</p>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>autoSKZCAM<ul> <li>analysis</li> <li>calculators</li> <li>data</li> <li>embed</li> <li>io</li> <li>oniom</li> <li>quacc</li> <li>recipes</li> <li>recipes_dft</li> <li>recipes_skzcam</li> <li>types</li> </ul> </li> </ul>"},{"location":"reference/autoSKZCAM/analysis.html","title":"analysis","text":""},{"location":"reference/autoSKZCAM/analysis.html#autoSKZCAM.analysis.analyze_calculations","title":"analyze_calculations","text":"<pre><code>analyze_calculations(calc_dir: Path | str, embedded_cluster_path: Path | str | None = None, EmbeddedCluster: CreateEmbeddedCluster | None = None) -&gt; dict[int, list[str]]\n</code></pre> <p>Analyze the calculations performed in the calc_dir folder</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>Path | str</code>)           \u2013            <p>The directory containing the calculations to analyze.</p> </li> <li> <code>embedded_cluster_path</code>               (<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to load the EmbeddedCluster object if it is not provided.</p> </li> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster | None</code>, default:                   <code>None</code> )           \u2013            <p>The EmbeddedCluster object containing the cluster information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[int, list[str]]</code>           \u2013            <p>The dictionary containing the cluster number and the calculations performed.</p> </li> </ul> Source code in <code>autoSKZCAM/analysis.py</code> <pre><code>def analyze_calculations(\n    calc_dir: Path | str,\n    embedded_cluster_path: Path | str | None = None,\n    EmbeddedCluster: CreateEmbeddedCluster | None = None,\n) -&gt; dict[int, list[str]]:\n    \"\"\"\n    Analyze the calculations performed in the calc_dir folder\n\n    Parameters\n    ----------\n    calc_dir\n        The directory containing the calculations to analyze.\n    embedded_cluster_path\n        The path to load the EmbeddedCluster object if it is not provided.\n    EmbeddedCluster\n        The EmbeddedCluster object containing the cluster information.\n\n    Returns\n    -------\n    dict[int, list[str]]\n        The dictionary containing the cluster number and the calculations performed.\n\n    \"\"\"\n\n    # If EmbeddedCluster is None, check that embedded_cluster_path is not None\n    if EmbeddedCluster is None and embedded_cluster_path is None:\n        embedded_cluster_path = Path(calc_dir, \"embedded_cluster.npy\")\n        # Check that the embedded_cluster_path exists\n        if not embedded_cluster_path.exists():\n            raise ValueError(\n                \"The embedded_cluster_path or EmbeddedCluster object must be provided.\"\n            )\n        EmbeddedCluster = np.load(embedded_cluster_path, allow_pickle=True).item()\n    elif EmbeddedCluster is None and embedded_cluster_path is not None:\n        EmbeddedCluster = np.load(embedded_cluster_path, allow_pickle=True).item()\n\n    # Check that EmbeddedCluster.skzcam_calcs is not None\n    if EmbeddedCluster.skzcam_calcs is None:\n        raise ValueError(\n            \"The skzcam_calcs attribute of the EmbeddedCluster object is None.\"\n        )\n\n    skzcam_calcs_analysis = {\n        cluster_num: {calculation_label: {} for calculation_label in calculation_labels}\n        for cluster_num, calculation_labels in EmbeddedCluster.skzcam_calcs.items()\n    }\n\n    for cluster_num, calculations_list in EmbeddedCluster.skzcam_calcs.items():\n        cluster_size = len(\n            EmbeddedCluster.quantum_cluster_indices_set[cluster_num - 1]\n        ) - len(EmbeddedCluster.adsorbate)\n        for calculation_label in calculations_list:\n            code = calculation_label.split(\" \")[0]\n            method = calculation_label.split(\" \")[1]\n            frozen_core = calculation_label.split(\" \")[2]\n            basis_set = calculation_label.split(\" \")[3]\n            for structure in [\"adsorbate_slab\", \"adsorbate\", \"slab\"]:\n                system_path = Path(\n                    calc_dir,\n                    str(cluster_num),\n                    code,\n                    f\"{method}_{basis_set}_{frozen_core}\",\n                    structure,\n                    f\"{code}.out\",\n                )\n                skzcam_calcs_analysis[cluster_num][calculation_label][structure] = (\n                    parse_energy(filename=system_path, code=code)\n                )\n            energy_dict = {}\n            for method in skzcam_calcs_analysis[cluster_num][calculation_label][\n                \"adsorbate\"\n            ]:\n                if (\n                    skzcam_calcs_analysis[cluster_num][calculation_label][\"adsorbate\"][\n                        method\n                    ]\n                    is not None\n                ):\n                    energy_dict[method] = (\n                        skzcam_calcs_analysis[cluster_num][calculation_label][\n                            \"adsorbate_slab\"\n                        ][method]\n                        - skzcam_calcs_analysis[cluster_num][calculation_label][\"slab\"][\n                            method\n                        ]\n                        - skzcam_calcs_analysis[cluster_num][calculation_label][\n                            \"adsorbate\"\n                        ][method]\n                    )\n                else:\n                    energy_dict[method] = None\n            skzcam_calcs_analysis[cluster_num][calculation_label][\"int_ene\"] = (\n                energy_dict\n            )\n        skzcam_calcs_analysis[cluster_num][\"cluster_size\"] = cluster_size\n    return skzcam_calcs_analysis\n</code></pre>"},{"location":"reference/autoSKZCAM/analysis.html#autoSKZCAM.analysis.compute_skzcam_int_ene","title":"compute_skzcam_int_ene","text":"<pre><code>compute_skzcam_int_ene(skzcam_calcs_analysis: dict[int, list[str]], OniomInfo: dict[str, OniomLayerInfo]) -&gt; (dict[str, list[float]], dict[str, dict[str, ndarray]])\n</code></pre> <p>Computes the interaction energy contributions for each ONIOM layer in the SKZCAM protocol.</p> <p>Parameters:</p> <ul> <li> <code>skzcam_calcs_analysis</code>               (<code>dict[int, list[str]]</code>)           \u2013            <p>The dictionary containing the SKZCAM calculations analysis.</p> </li> <li> <code>OniomInfo</code>               (<code>dict[str, OniomLayerInfo]</code>)           \u2013            <p>The dictionary containing the ONIOM layer information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[float]]</code>           \u2013            <p>The interaction energy and error contributions for each ONIOM layer in the SKZCAM protocol.</p> </li> <li> <code>dict[str, dict[str, ndarray]]</code>           \u2013            <p>For each ONIOM layer, the interaction energy contributions for each cluster size is stored as a list.</p> </li> </ul> Source code in <code>autoSKZCAM/analysis.py</code> <pre><code>def compute_skzcam_int_ene(\n    skzcam_calcs_analysis: dict[int, list[str]], OniomInfo: dict[str, OniomLayerInfo]\n) -&gt; (dict[str, list[float]], dict[str, dict[str, np.ndarray]]):\n    \"\"\"\n    Computes the interaction energy contributions for each ONIOM layer in the SKZCAM protocol.\n\n    Parameters\n    ----------\n    skzcam_calcs_analysis\n        The dictionary containing the SKZCAM calculations analysis.\n    OniomInfo\n        The dictionary containing the ONIOM layer information.\n\n    Returns\n    -------\n    dict[str,list[float]]\n        The interaction energy and error contributions for each ONIOM layer in the SKZCAM protocol.\n    dict[str, dict[str, np.ndarray]]\n        For each ONIOM layer, the interaction energy contributions for each cluster size is stored as a list.\n    \"\"\"\n\n    skzcam_int_ene = {layer_name: [0, 0] for layer_name in OniomInfo}\n    oniom_layer_int_ene = {}\n\n    for layer_name, oniom_layer in OniomInfo.items():\n        cluster_level_int_ene = {\"ll\": [], \"hl\": []}\n        for level in [\"ll\", \"hl\"]:\n            if oniom_layer[level] is not None:\n                oniom_layer_parameters = oniom_layer[level]\n                frozen_core = oniom_layer_parameters[\"frozen_core\"]\n                method = oniom_layer_parameters[\"method\"].replace(\" \", \"_\")\n                code = oniom_layer_parameters[\"code\"].lower()\n                max_cluster_num = oniom_layer_parameters[\"max_cluster_num\"]\n\n                # Check the basis set family\n                basis_set_family = \"mixcc\"\n                if (\n                    \"element_info\" in oniom_layer_parameters\n                    and oniom_layer_parameters[\"element_info\"] is not None\n                ):\n                    for element in oniom_layer_parameters[\"element_info\"]:\n                        if (\n                            \"def2\"\n                            in oniom_layer_parameters[\"element_info\"][element][\"basis\"]\n                        ):\n                            basis_set_family = \"def2\"\n\n                if \"mp2\" in method.lower():\n                    method_type = \"mp2\"\n                elif \"ccsd(t)\" in method.lower():\n                    method_type = \"ccsdt\"\n                elif \"ccsd\" in method.lower():\n                    method_type = \"ccsd\"\n                else:\n                    raise ValueError(\"The method cannot be analysed automatically.\")\n                (is_cbs, basis_1, basis_2) = is_valid_cbs_format(\n                    oniom_layer_parameters[\"basis\"]\n                )\n                if is_cbs:\n                    basis_sets = [basis_1, basis_2]\n                else:\n                    basis_sets = [oniom_layer_parameters[\"basis\"]]\n\n                for cluster_num in range(1, max_cluster_num + 1):\n                    basis_set_scf_int_ene_list = []\n                    basis_set_corr_int_ene_list = []\n                    for _basis_idx, basis_set in enumerate(basis_sets):\n                        # Use the\n                        if (\n                            (\n                                code == \"mrcc\"\n                                and level == \"ll\"\n                                and \"MP2\" in oniom_layer[\"ll\"][\"method\"].upper()\n                                and \"CCSD(T)\" in oniom_layer[\"hl\"][\"method\"].upper()\n                            )\n                            or (\n                                code == \"mrcc\"\n                                and level == \"ll\"\n                                and \"CCSD\" in oniom_layer[\"ll\"][\"method\"].upper()\n                                and \"CCSD(T)\" in oniom_layer[\"hl\"][\"method\"].upper()\n                            )\n                            or (\n                                code == \"orca\"\n                                and level == \"ll\"\n                                and oniom_layer[\"ll\"][\"method\"].upper() == \"MP2\"\n                                and oniom_layer[\"hl\"][\"method\"].upper() == \"CCSD(T)\"\n                            )\n                        ):\n                            calculation_label = f\"{code} {oniom_layer['hl']['method']} {frozen_core} {basis_set}\"\n                        else:\n                            calculation_label = (\n                                f\"{code} {method} {frozen_core} {basis_set}\"\n                            )\n                        if (\n                            calculation_label in skzcam_calcs_analysis[cluster_num]\n                            and calculation_label != \"cluster_size\"\n                        ):\n                            basis_set_scf_int_ene_list += [\n                                skzcam_calcs_analysis[cluster_num][calculation_label][\n                                    \"int_ene\"\n                                ][\"scf_energy\"]\n                            ]\n                            basis_set_corr_int_ene_list += [\n                                _get_method_int_ene(\n                                    energy_dict=skzcam_calcs_analysis[cluster_num][\n                                        calculation_label\n                                    ][\"int_ene\"],\n                                    method_type=method_type,\n                                )\n                            ]\n                    if is_cbs:\n                        cluster_level_int_ene[level] += [\n                            get_cbs_extrapolation(\n                                basis_set_scf_int_ene_list[0],\n                                basis_set_corr_int_ene_list[0],\n                                basis_set_scf_int_ene_list[1],\n                                basis_set_corr_int_ene_list[1],\n                                X_size=basis_sets[0],\n                                Y_size=basis_sets[1],\n                                family=basis_set_family,\n                            )[-1]\n                        ]\n                    else:\n                        cluster_level_int_ene[level] += [\n                            basis_set_corr_int_ene_list[0]\n                            + basis_set_scf_int_ene_list[0]\n                        ]\n\n        cluster_level_int_ene[\"ll\"] = np.array(cluster_level_int_ene[\"ll\"])\n        cluster_level_int_ene[\"hl\"] = np.array(cluster_level_int_ene[\"hl\"])\n        oniom_layer_int_ene[layer_name] = cluster_level_int_ene\n\n        if \"extrapolate\" in layer_name.lower() and \"bulk\" in layer_name.lower():\n            skzcam_int_ene[layer_name] = [\n                extrapolate_to_bulk(\n                    [\n                        skzcam_calcs_analysis[cluster_num][\"cluster_size\"]\n                        for cluster_num in range(\n                            1, oniom_layer[\"hl\"][\"max_cluster_num\"] + 1\n                        )\n                    ],\n                    cluster_level_int_ene[\"hl\"],\n                ),\n                0,\n            ]\n        elif \"bulk\" in layer_name.lower():\n            skzcam_int_ene[layer_name] = [cluster_level_int_ene[\"hl\"][-1], 0]\n        elif \"fse\" in layer_name.lower():\n            skzcam_int_ene[layer_name] = [\n                0,\n                abs(\n                    extrapolate_to_bulk(\n                        [\n                            skzcam_calcs_analysis[cluster_num][\"cluster_size\"]\n                            for cluster_num in range(\n                                1, oniom_layer[\"hl\"][\"max_cluster_num\"] + 1\n                            )\n                        ],\n                        cluster_level_int_ene[\"hl\"],\n                    )\n                    - extrapolate_to_bulk(\n                        [\n                            skzcam_calcs_analysis[cluster_num][\"cluster_size\"]\n                            for cluster_num in range(\n                                1, oniom_layer[\"ll\"][\"max_cluster_num\"] + 1\n                            )\n                        ],\n                        cluster_level_int_ene[\"ll\"],\n                    )\n                ),\n            ]\n        elif \"delta\" in layer_name.lower():\n            if max_cluster_num &lt; 3:\n                skzcam_int_ene[layer_name] = [\n                    np.mean(cluster_level_int_ene[\"hl\"] - cluster_level_int_ene[\"ll\"]),\n                    0,\n                ]\n            else:\n                skzcam_int_ene[layer_name] = [\n                    np.mean(cluster_level_int_ene[\"hl\"] - cluster_level_int_ene[\"ll\"]),\n                    2\n                    * np.std(cluster_level_int_ene[\"hl\"] - cluster_level_int_ene[\"ll\"]),\n                ]\n\n    # Compute the final SKZCAM interaction energy\n    final_int_ene = np.sum(\n        [skzcam_int_ene[layer_name][0] for layer_name in skzcam_int_ene]\n    )\n    final_int_ene_error = np.sqrt(\n        np.sum([skzcam_int_ene[layer_name][1] ** 2 for layer_name in skzcam_int_ene])\n    )\n\n    skzcam_int_ene[\"Overall Eint\"] = [final_int_ene, final_int_ene_error]\n\n    # Multiply all terms by 1000 to convert to meV\n\n    return {\n        key: [value[0] * 1000, value[1] * 1000] for key, value in skzcam_int_ene.items()\n    }, oniom_layer_int_ene\n</code></pre>"},{"location":"reference/autoSKZCAM/analysis.html#autoSKZCAM.analysis.extrapolate_to_bulk","title":"extrapolate_to_bulk","text":"<pre><code>extrapolate_to_bulk(x_data: list[float], y_data: list[float]) -&gt; float\n</code></pre> <p>Function to perform a linear fit of 1/x_data vs y_data to extrapolate to the bulk limit.</p> <p>Parameters:</p> <ul> <li> <code>x_data</code>               (<code>list[float]</code>)           \u2013            <p>The x data points.</p> </li> <li> <code>y_data</code>               (<code>list[float]</code>)           \u2013            <p>The y data points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The bulk limit, which is the zero intercept of the linear fit.</p> </li> </ul> Source code in <code>autoSKZCAM/analysis.py</code> <pre><code>def extrapolate_to_bulk(x_data: list[float], y_data: list[float]) -&gt; float:\n    \"\"\"\n    Function to perform a linear fit of 1/x_data vs y_data to extrapolate to the bulk limit.\n\n    Parameters\n    ----------\n    x_data\n        The x data points.\n    y_data\n        The y data points.\n\n    Returns\n    -------\n    float\n        The bulk limit, which is the zero intercept of the linear fit.\n    \"\"\"\n\n    x_transformed_data = np.array([1 / x for x in x_data])\n\n    # Degree of the polynomial\n    degree = 1  # You can change the degree based on your requirement\n\n    # Perform the polynomial fit\n    coefficients = np.polyfit(x_transformed_data, y_data, degree)\n\n    # Print the coefficients of the polynomial\n    return coefficients[1]\n</code></pre>"},{"location":"reference/autoSKZCAM/analysis.html#autoSKZCAM.analysis.get_cbs_extrapolation","title":"get_cbs_extrapolation","text":"<pre><code>get_cbs_extrapolation(hf_X: float, corr_X: float, hf_Y: float, corr_Y: float, X_size: Literal['DZ', 'TZ', 'QZ'] = 'DZ', Y_size: Literal['TZ', 'QZ', '5Z'] = 'TZ', family: Literal['def2', 'cc', 'acc', 'mixcc'] = 'mixcc') -&gt; tuple[float, float, float]\n</code></pre> <p>Function to perform basis set extrapolation of HF and correlation energies for both the cc-pVXZ and def2-XZVP basis sets</p> <p>Parameters:</p> <ul> <li> <code>hf_X</code>               (<code>float</code>)           \u2013            <p>HF energy in X basis set</p> </li> <li> <code>corr_X</code>               (<code>float</code>)           \u2013            <p>Correlation energy in X basis set</p> </li> <li> <code>hf_Y</code>               (<code>float</code>)           \u2013            <p>HF energy in Y basis set where Y = X+1 cardinal zeta number</p> </li> <li> <code>corr_Y</code>               (<code>float</code>)           \u2013            <p>Correlation energy in Y basis set</p> </li> <li> <code>X_size</code>               (<code>str</code>, default:                   <code>'DZ'</code> )           \u2013            <p>Cardinal zeta number of X basis set</p> </li> <li> <code>Y_size</code>               (<code>str</code>, default:                   <code>'TZ'</code> )           \u2013            <p>Cardinal zeta number of Y basis set</p> </li> <li> <code>family</code>               (<code>str</code>, default:                   <code>'mixcc'</code> )           \u2013            <p>Basis set family. Options are <code>cc</code>, <code>def2</code>, <code>acc</code>, and <code>mixcc</code>. Where cc is for non-augmented correlation consistent basis sets, def2 is for def2 basis sets, acc is for augmented correlation consistent basis sets while mixcc is for mixed augmented + non-augmented correlation consistent basis sets</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>hf_cbs</code> (              <code>float</code> )          \u2013            <p>HF CBS energy</p> </li> <li> <code>corr_cbs</code> (              <code>float</code> )          \u2013            <p>Correlation CBS energy</p> </li> <li> <code>tot_cbs</code> (              <code>float</code> )          \u2013            <p>Total CBS energy</p> </li> </ul> Source code in <code>autoSKZCAM/analysis.py</code> <pre><code>def get_cbs_extrapolation(\n    hf_X: float,\n    corr_X: float,\n    hf_Y: float,\n    corr_Y: float,\n    X_size: Literal[\"DZ\", \"TZ\", \"QZ\"] = \"DZ\",\n    Y_size: Literal[\"TZ\", \"QZ\", \"5Z\"] = \"TZ\",\n    family: Literal[\"def2\", \"cc\", \"acc\", \"mixcc\"] = \"mixcc\",\n) -&gt; tuple[float, float, float]:\n    \"\"\"\n    Function to perform basis set extrapolation of HF and correlation energies for both the cc-pVXZ and def2-XZVP basis sets\n\n    Parameters\n    ----------\n    hf_X : float\n        HF energy in X basis set\n    corr_X : float\n        Correlation energy in X basis set\n    hf_Y : float\n        HF energy in Y basis set where Y = X+1 cardinal zeta number\n    corr_Y : float\n        Correlation energy in Y basis set\n    X_size : str\n        Cardinal zeta number of X basis set\n    Y_size : str\n        Cardinal zeta number of Y basis set\n    family : str\n        Basis set family. Options are `cc`, `def2`, `acc`, and `mixcc`. Where cc is for non-augmented correlation consistent basis sets, def2 is for def2 basis sets, acc is for augmented correlation consistent basis sets while mixcc is for mixed augmented + non-augmented correlation consistent basis sets\n\n    Returns\n    -------\n    hf_cbs : float\n        HF CBS energy\n    corr_cbs : float\n        Correlation CBS energy\n    tot_cbs : float\n        Total CBS energy\n    \"\"\"\n\n    # Dictionary of alpha parameters followed by beta parameters in CBS extrapoation. Refer to: Neese, F.; Valeev, E. F. Revisiting the Atomic Natural Orbital Approach for Basis Sets: Robust Systematic Basis Sets for Explicitly Correlated and Conventional Correlated Ab Initio Methods. J. Chem. Theory Comput. 2011, 7 (1), 33-43. https://doi.org/10.1021/ct100396y.\n    alpha_dict = {\n        \"def2_2_3\": 10.39,\n        \"def2_3_4\": 7.88,\n        \"cc_2_3\": 4.42,\n        \"cc_3_4\": 5.46,\n        \"cc_4_5\": 5.46,\n        \"acc_2_3\": 4.30,\n        \"acc_3_4\": 5.79,\n        \"acc_4_5\": 5.79,\n        \"mixcc_2_3\": 4.36,\n        \"mixcc_3_4\": 5.625,\n        \"mixcc_4_5\": 5.625,\n    }\n\n    beta_dict = {\n        \"def2_2_3\": 2.40,\n        \"def2_3_4\": 2.97,\n        \"cc_2_3\": 2.46,\n        \"cc_3_4\": 3.05,\n        \"cc_4_5\": 3.05,\n        \"acc_2_3\": 2.51,\n        \"acc_3_4\": 3.05,\n        \"acc_4_5\": 3.05,\n        \"mixcc_2_3\": 2.485,\n        \"mixcc_3_4\": 3.05,\n        \"mixcc_4_5\": 3.05,\n    }\n\n    size_to_num = {\"DZ\": 2, \"TZ\": 3, \"QZ\": 4, \"5Z\": 5}\n\n    X = size_to_num[X_size]\n    Y = size_to_num[Y_size]\n\n    # Check if X and Y are consecutive cardinal zeta numbers\n    if Y != X + 1:\n        raise ValueError(\"The cardinal number of Y does not equal X+1\")\n\n    # Get the corresponding alpha and beta parameters depending on the basis set family\n    alpha = alpha_dict[f\"{family}_{X}_{Y}\"]\n    beta = beta_dict[f\"{family}_{X}_{Y}\"]\n\n    # Perform CBS extrapolation for HF and correlation components\n    hf_cbs = hf_X - np.exp(-alpha * np.sqrt(X)) * (hf_Y - hf_X) / (\n        np.exp(-alpha * np.sqrt(Y)) - np.exp(-alpha * np.sqrt(X))\n    )\n    corr_cbs = (X ** (beta) * corr_X - Y ** (beta) * corr_Y) / (\n        X ** (beta) - Y ** (beta)\n    )\n\n    return hf_cbs, corr_cbs, (hf_cbs + corr_cbs)\n</code></pre>"},{"location":"reference/autoSKZCAM/analysis.html#autoSKZCAM.analysis.get_quasi_rrho","title":"get_quasi_rrho","text":"<pre><code>get_quasi_rrho(r_freq, i_freq, T) -&gt; tuple[float, float, float, float]\n</code></pre> <p>Uses the quasi rigid rotor harmonic approximation to calculate the thermal change and zero-point energies from vibrational frequencies in cm-1 and a temperature in Kelvin.</p> <p>Parameters:</p> <ul> <li> <code>r_freq</code>               (<code>list</code>)           \u2013            <p>List of real vibrational frequencies in cm-1.</p> </li> <li> <code>i_freq</code>               (<code>list</code>)           \u2013            <p>List of imaginary vibrational frequencies in cm-1.</p> </li> <li> <code>T</code>               (<code>float</code>)           \u2013            <p>Temperature in Kelvin.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dU</code> (              <code>float</code> )          \u2013            <p>The total change in energy including thermal energy and zero-point energy in eV.</p> </li> <li> <code>eth</code> (              <code>float</code> )          \u2013            <p>The thermal energy in eV.</p> </li> <li> <code>zpe</code> (              <code>float</code> )          \u2013            <p>The zero-point energy in eV.</p> </li> <li> <code>kT</code> (              <code>float</code> )          \u2013            <p>The product of Boltzmann constant (kB) and temperature (kT) in eV.</p> </li> </ul> Source code in <code>autoSKZCAM/analysis.py</code> <pre><code>def get_quasi_rrho(r_freq, i_freq, T) -&gt; tuple[float, float, float, float]:\n    \"\"\"\n    Uses the quasi rigid rotor harmonic approximation to calculate the thermal change and zero-point energies from vibrational frequencies in cm-1 and a temperature in Kelvin.\n\n    Parameters\n    ----------\n    r_freq : list\n        List of real vibrational frequencies in cm-1.\n    i_freq : list\n        List of imaginary vibrational frequencies in cm-1.\n    T : float\n        Temperature in Kelvin.\n\n    Returns\n    -------\n    dU : float\n        The total change in energy including thermal energy and zero-point energy in eV.\n    eth : float\n        The thermal energy in eV.\n    zpe : float\n        The zero-point energy in eV.\n    kT : float\n        The product of Boltzmann constant (kB) and temperature (kT) in eV.\n    \"\"\"\n\n    k = 8.617330337217213e-05  # Boltzmann constant\n    hundredcm1 = 100000 / 8065.54429\n    combined_freq = r_freq + [0.0001] * len(\n        i_freq\n    )  # Combine real and imaginary frequencies\n    kT = k * T * 1000  # Calculate kT in eV\n\n    dU = 0  # Initialize total energy change\n    zpe = 0.0  # Initialize zero-point energy correction\n    eth = 0.0  # Initialize thermal energy contribution\n    for i in combined_freq:\n        omega = 1 / (\n            1 + ((hundredcm1 / i) ** 4)\n        )  # Calculate the vibrational frequenecy in meV\n        dURRho = (\n            i / (np.exp(i / kT) - 1.0) + 0.5 * i\n        )  # Calculate the contribution to thermal energy from this frequency\n        zpe += omega * 0.5 * i  # Calculate the contribution to zero-point energy\n        eth += (\n            omega * i / (np.exp(i / kT) - 1.0) + (1 - omega) * 0.5 * kT\n        )  # Calculate the thermal energy contribution\n        dU += (\n            omega * dURRho + (1 - omega) * 0.5 * kT\n        )  # Calculate the total energy change\n\n    return dU, eth, zpe, kT  # Return the calculated values\n</code></pre>"},{"location":"reference/autoSKZCAM/analysis.html#autoSKZCAM.analysis.parse_energy","title":"parse_energy","text":"<pre><code>parse_energy(filename, code='mrcc') -&gt; dict[str, float]\n</code></pre> <p>Function to parse the energy from a MRCC or ORCA output file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The location of the output file to read from.</p> </li> <li> <code>code</code>               (<code>str</code>, default:                   <code>'mrcc'</code> )           \u2013            <p>The code format. Options are 'mrcc' and 'orca'</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, float]</code>           \u2013            <p>A dictionary containing the energies parsed from the output file.</p> </li> </ul> Source code in <code>autoSKZCAM/analysis.py</code> <pre><code>def parse_energy(filename, code=\"mrcc\") -&gt; dict[str, float]:\n    \"\"\"\n    Function to parse the energy from a MRCC or ORCA output file.\n\n    Parameters\n    ----------\n    filename : str\n        The location of the output file to read from.\n    code : str\n        The code format. Options are 'mrcc' and 'orca'\n\n    Returns\n    -------\n    dict[str, float]\n        A dictionary containing the energies parsed from the output file.\n    \"\"\"\n\n    if code == \"mrcc\":\n        energy_dict = read_mrcc_outputs(filename)\n\n    elif code == \"orca\":\n        energy_dict = read_orca_outputs(filename)\n\n    return energy_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/calculators.html","title":"calculators","text":""},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.MRCC","title":"MRCC","text":"<pre><code>MRCC(*, profile: MrccProfile = None, directory: str | Path = '.', **kwargs)\n</code></pre> <p>               Bases: <code>GenericFileIOCalculator</code></p> <p>Class for performing MRCC calculations.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>               (<code>MrccProfile</code>, default:                   <code>None</code> )           \u2013            <p>The MRCC profile to use.</p> </li> <li> <code>directory</code>               (<code>str | Path</code>, default:                   <code>'.'</code> )           \u2013            <p>The directory in which to run the calculation.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>The parameters for the MRCC calculation.</p> </li> </ul> <p>Examples:</p> <p>Use default values:</p> <pre><code>&gt;&gt;&gt; from quacc.calculators.mrcc.mrcc import MRCC, MrccProfile\n&gt;&gt;&gt; from ase.build import molecule\n&gt;&gt;&gt; from quacc import get_settings\n</code></pre> <pre><code>&gt;&gt;&gt; calc = MRCC(\n...     profile=MrccProfile(command=get_settings().MRCC_CMD),\n...     charge=0,\n...     mult=1,\n...     basis=\"def2-SVP\",\n...     calc=\"PBE\",\n... )\n&gt;&gt;&gt; h = molecule(\"H2\")\n&gt;&gt;&gt; h.set_calculator(calc)\n&gt;&gt;&gt; h.get_total_energy()\n</code></pre> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/calculators.py</code> <pre><code>def __init__(\n    self, *, profile: MrccProfile = None, directory: str | Path = \".\", **kwargs\n) -&gt; None:\n    \"\"\"\n    Construct MRCC-calculator object.\n\n    Parameters\n    ----------\n    profile: MrccProfile\n        The MRCC profile to use.\n    directory: str\n        The directory in which to run the calculation.\n    **kwargs\n        The parameters for the MRCC calculation.\n\n    Examples\n    --------\n    Use default values:\n\n    &gt;&gt;&gt; from quacc.calculators.mrcc.mrcc import MRCC, MrccProfile\n    &gt;&gt;&gt; from ase.build import molecule\n    &gt;&gt;&gt; from quacc import get_settings\n\n    &gt;&gt;&gt; calc = MRCC(\n    ...     profile=MrccProfile(command=get_settings().MRCC_CMD),\n    ...     charge=0,\n    ...     mult=1,\n    ...     basis=\"def2-SVP\",\n    ...     calc=\"PBE\",\n    ... )\n    &gt;&gt;&gt; h = molecule(\"H2\")\n    &gt;&gt;&gt; h.set_calculator(calc)\n    &gt;&gt;&gt; h.get_total_energy()\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    super().__init__(\n        template=SkzcamMrccTemplate(),\n        profile=profile,\n        directory=directory,\n        parameters=kwargs,\n    )\n</code></pre>"},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.ORCA","title":"ORCA","text":"<pre><code>ORCA(*, profile=None, directory='.', **kwargs)\n</code></pre> <p>               Bases: <code>GenericFileIOCalculator</code></p> <p>Class for performing ORCA calculations.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>           \u2013            <p>The ORCA profile to use.</p> </li> <li> <code>directory</code>           \u2013            <p>The directory in which to run the calculation.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>The parameters for the ORCA calculation.</p> </li> </ul> <p>Examples:</p> <p>Use default values:</p> <pre><code>&gt;&gt;&gt; from ase.calculators.orca import ORCA\n&gt;&gt;&gt; h = Atoms(\n...     \"H\",\n...     calculator=ORCA(\n...         charge=0,\n...         mult=1,\n...         directory=\"water\",\n...         orcasimpleinput=\"B3LYP def2-TZVP\",\n...         orcablocks=\"%pal nprocs 16 end\",\n...     ),\n... )\n</code></pre> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/calculators.py</code> <pre><code>def __init__(self, *, profile=None, directory=\".\", **kwargs):\n    \"\"\"\n    Construct ORCA-calculator object.\n\n    Parameters\n    ----------\n    profile: OrcaProfile\n        The ORCA profile to use.\n    directory: str\n        The directory in which to run the calculation.\n    **kwargs\n        The parameters for the ORCA calculation.\n\n\n    Examples\n    --------\n    Use default values:\n\n    &gt;&gt;&gt; from ase.calculators.orca import ORCA\n    &gt;&gt;&gt; h = Atoms(\n    ...     \"H\",\n    ...     calculator=ORCA(\n    ...         charge=0,\n    ...         mult=1,\n    ...         directory=\"water\",\n    ...         orcasimpleinput=\"B3LYP def2-TZVP\",\n    ...         orcablocks=\"%pal nprocs 16 end\",\n    ...     ),\n    ... )\n\n    Returns\n    -------\n    None\n\n    \"\"\"\n\n    super().__init__(\n        template=SkzcamOrcaTemplate(),\n        profile=profile,\n        directory=directory,\n        parameters=kwargs,\n    )\n</code></pre>"},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.SkzcamMrccTemplate","title":"SkzcamMrccTemplate","text":"<p>               Bases: <code>MrccTemplate</code></p> <p>The MRCC calculator template class to be used for (auto)SKZCAM calculations.</p>"},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.SkzcamMrccTemplate.write_input","title":"write_input","text":"<pre><code>write_input(profile: MrccProfile, directory: Path | str, atoms: Atoms, parameters: dict[str, str], properties: dict[str, Any]) -&gt; None\n</code></pre> <p>Write the MRCC input file.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>               (<code>MrccProfile</code>)           \u2013            <p>The MrccProfile class.</p> </li> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which to write the input file.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>parameters</code>               (<code>dict[str, str]</code>)           \u2013            <p>The parameters for the calculation.</p> </li> <li> <code>properties</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The properties to calculate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/calculators.py</code> <pre><code>def write_input(\n    self,\n    profile: MrccProfile,  # noqa: ARG002\n    directory: Path | str,\n    atoms: Atoms,\n    parameters: dict[str, str],\n    properties: dict[str, Any],  # noqa: ARG002\n) -&gt; None:\n    \"\"\"\n    Write the MRCC input file.\n\n    Parameters\n    ----------\n    profile\n        The MrccProfile class.\n    directory\n        The directory in which to write the input file.\n    atoms\n        The Atoms object.\n    parameters\n        The parameters for the calculation.\n    properties\n        The properties to calculate.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    parameters = dict(parameters)\n\n    kw = {\"charge\": 0, \"mult\": 1, \"calc\": \"PBE\", \"basis\": \"def2-SVP\"}\n    kw.update(parameters)\n\n    if \"genbas\" in parameters and parameters[\"genbas\"] is not None:\n        with Path.open(directory / \"GENBAS\", \"w\") as genbas_file:\n            genbas_file.write(parameters[\"genbas\"])\n        # Remove 'genbas' from kw, as it is not an MRCC keyword\n        del kw[\"genbas\"]\n\n    write_mrcc(directory / self.inputname, atoms, kw)\n</code></pre>"},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.SkzcamOrcaTemplate","title":"SkzcamOrcaTemplate","text":"<p>               Bases: <code>OrcaTemplate</code></p> <p>The ORCA calculator template class to be used for (auto)SKZCAM calculations.</p>"},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.SkzcamOrcaTemplate.write_input","title":"write_input","text":"<pre><code>write_input(profile: OrcaProfile, directory: Path | str, atoms: Atoms, parameters: dict[str, str], properties: dict[str, Any]) -&gt; None\n</code></pre> <p>Write the MRCC input file.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>               (<code>OrcaProfile</code>)           \u2013            <p>The OrcaProfile class.</p> </li> <li> <code>directory</code>               (<code>Path | str</code>)           \u2013            <p>The directory in which to write the input file.</p> </li> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>The Atoms object.</p> </li> <li> <code>parameters</code>               (<code>dict[str, str]</code>)           \u2013            <p>The parameters for the calculation.</p> </li> <li> <code>properties</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The properties to calculate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/calculators.py</code> <pre><code>def write_input(\n    self,\n    profile: OrcaProfile,  # noqa: ARG002\n    directory: Path | str,\n    atoms: Atoms,\n    parameters: dict[str, str],\n    properties: dict[str, Any],  # noqa: ARG002\n) -&gt; None:\n    \"\"\"\n    Write the MRCC input file.\n\n    Parameters\n    ----------\n    profile\n        The OrcaProfile class.\n    directory\n        The directory in which to write the input file.\n    atoms\n        The Atoms object.\n    parameters\n        The parameters for the calculation.\n    properties\n        The properties to calculate.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    parameters = dict(parameters)\n\n    kw = {\n        \"charge\": 0,\n        \"mult\": 1,\n        \"orcasimpleinput\": \"B3LYP def2-TZVP\",\n        \"orcablocks\": \"%pal nprocs 1 end\",\n    }\n    kw.update(parameters)\n    if \"pointcharges\" in parameters and parameters[\"pointcharges\"] is not None:\n        with Path.open(directory / \"orca.pc\", \"w\") as pc_file:\n            pc_file.write(parameters[\"pointcharges\"])\n        # Remove 'pointcharges' from kw, as it is not an ORCA keyword\n        del kw[\"pointcharges\"]\n\n    write_orca(directory / self.inputname, atoms, kw)\n</code></pre>"},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.read_orca_energy","title":"read_orca_energy","text":"<pre><code>read_orca_energy(lines: list[str]) -&gt; EnergyInfo\n</code></pre> <p>Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the ORCA output file where available.</p> <p>Parameters:</p> <ul> <li> <code>lines</code>               (<code>list[str]</code>)           \u2013            <p>List of lines read from the ORCA output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EnergyInfo</code>           \u2013            <p>Dictionary with the energy components. The keys are:</p> <ul> <li> <p>energy (<code>float</code>):   Total energy (not computed in this function).</p> </li> <li> <p>scf_energy (<code>float</code>):   SCF energy.</p> </li> <li> <p>mp2_corr_energy (<code>float</code>):   MP2 correlation energy.</p> </li> <li> <p>ccsd_corr_energy (<code>float</code>):   CCSD correlation energy.</p> </li> <li> <p>ccsdt_corr_energy (<code>float</code>):   CCSD(T) correlation energy.</p> </li> </ul> </li> </ul> Source code in <code>autoSKZCAM/calculators.py</code> <pre><code>def read_orca_energy(lines: list[str]) -&gt; EnergyInfo:\n    \"\"\"\n    Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the ORCA output file where available.\n\n    Parameters\n    ----------\n    lines : list[str]\n        List of lines read from the ORCA output file.\n\n    Returns\n    -------\n    EnergyInfo\n        Dictionary with the energy components. The keys are:\n\n        - **energy** (`float`):\n          Total energy (not computed in this function).\n\n        - **scf_energy** (`float`):\n          SCF energy.\n\n        - **mp2_corr_energy** (`float`):\n          MP2 correlation energy.\n\n        - **ccsd_corr_energy** (`float`):\n          CCSD correlation energy.\n\n        - **ccsdt_corr_energy** (`float`):\n          CCSD(T) correlation energy.\n    \"\"\"\n\n    energy_dict = {\n        \"energy\": None,\n        \"scf_energy\": None,\n        \"mp2_corr_energy\": None,\n        \"ccsd_corr_energy\": None,\n        \"ccsdt_corr_energy\": None,\n    }\n\n    for line in lines:\n        if \"Total Energy       :\" in line:\n            energy_dict[\"scf_energy\"] = float(line.split()[-4]) * Hartree\n        elif (\n            \"MP2 CORRELATION ENERGY:\" in line\n            or \"E(MP2)\" in line\n            or \"E(RI-MP2)\" in line\n            or \"E(L-MP2)\" in line\n            or \"E(SL-MP2)\" in line\n        ):\n            energy_dict[\"mp2_corr_energy\"] = (\n                float(line.replace(\"Eh\", \"\").split()[-1]) * Hartree\n            )\n        elif \"E(CORR)\" in line:\n            energy_dict[\"ccsd_corr_energy\"] = float(line.split()[-1]) * Hartree\n        elif \"Final correlation energy\" in line:\n            energy_dict[\"ccsdt_corr_energy\"] = float(line.split()[-1]) * Hartree\n\n    return energy_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/calculators.html#autoSKZCAM.calculators.read_orca_outputs","title":"read_orca_outputs","text":"<pre><code>read_orca_outputs(output_file_path: Path | str) -&gt; EnergyInfo\n</code></pre> <p>Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the ORCA output file where available and calculates the total energy (based on the highest level of theory)</p> <p>Parameters:</p> <ul> <li> <code>output_file_path</code>               (<code>Path | str</code>)           \u2013            <p>Path to the ORCA output file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>EnergyInfo</code>           \u2013            <p>Dictionary with the energy components. The keys are:</p> <ul> <li> <p>energy (<code>float</code>):   Total energy (not computed in this function).</p> </li> <li> <p>scf_energy (<code>float</code>):   SCF energy.</p> </li> <li> <p>mp2_corr_energy (<code>float</code>):   MP2 correlation energy.</p> </li> <li> <p>ccsd_corr_energy (<code>float</code>):   CCSD correlation energy.</p> </li> <li> <p>ccsdt_corr_energy (<code>float</code>):   CCSD(T) correlation energy.</p> </li> </ul> </li> </ul> Source code in <code>autoSKZCAM/calculators.py</code> <pre><code>def read_orca_outputs(output_file_path: Path | str) -&gt; EnergyInfo:\n    \"\"\"\n    Reads the energy components (SCF energy, MP2 correlation energy, CCSD correlation energy, CCSD(T) correlation energy) from the ORCA output file where available and calculates the total energy (based on the highest level of theory)\n\n    Parameters\n    ----------\n    output_file_path : Path | str\n        Path to the ORCA output file.\n\n    Returns\n    -------\n    EnergyInfo\n        Dictionary with the energy components. The keys are:\n\n        - **energy** (`float`):\n          Total energy (not computed in this function).\n\n        - **scf_energy** (`float`):\n          SCF energy.\n\n        - **mp2_corr_energy** (`float`):\n          MP2 correlation energy.\n\n        - **ccsd_corr_energy** (`float`):\n          CCSD correlation energy.\n\n        - **ccsdt_corr_energy** (`float`):\n          CCSD(T) correlation energy.\n    \"\"\"\n    with Path.open(output_file_path) as output_textio:\n        lines = output_textio.readlines()\n\n    energy_dict = read_orca_energy(lines)\n\n    # Raise error if scf_energy is None\n    if energy_dict[\"scf_energy\"] is None:\n        raise ValueError(\"SCF energy not found in ORCA output file\")\n\n    if energy_dict[\"ccsdt_corr_energy\"] is not None:\n        energy_dict[\"energy\"] = (\n            energy_dict[\"scf_energy\"] + energy_dict[\"ccsdt_corr_energy\"]\n        )\n    elif energy_dict[\"ccsd_corr_energy\"] is not None:\n        energy_dict[\"energy\"] = (\n            energy_dict[\"scf_energy\"] + energy_dict[\"ccsd_corr_energy\"]\n        )\n    elif energy_dict[\"mp2_corr_energy\"] is not None:\n        energy_dict[\"energy\"] = (\n            energy_dict[\"scf_energy\"] + energy_dict[\"mp2_corr_energy\"]\n        )\n    else:\n        energy_dict[\"energy\"] = energy_dict[\"scf_energy\"]\n\n    return energy_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/data.html","title":"data","text":""},{"location":"reference/autoSKZCAM/data.html#autoSKZCAM.data.capped_ecp_defaults","title":"capped_ecp_defaults  <code>module-attribute</code>","text":"<pre><code>capped_ecp_defaults = {'orca': 'NewECP\\nN_core 0\\nlmax f\\ns 1\\n1      1.732000000   14.676000000 2\\np 1\\n1      1.115000000    5.175700000 2\\nd 1\\n1      1.203000000   -1.816000000 2\\nf 1\\n1      1.000000000    0.000000000 2\\nend', 'mrcc': '\\n*\\n    NCORE = 12    LMAX = 3\\nf\\n    0.000000000  2     1.000000000\\ns-f\\n   14.676000000  2     1.732000000\\np-f\\n    5.175700000  2     1.115000000\\nd-f\\n   -1.816000000  2     1.203000000\\n*'}\n</code></pre>"},{"location":"reference/autoSKZCAM/data.html#autoSKZCAM.data.code_calculation_defaults","title":"code_calculation_defaults  <code>module-attribute</code>","text":"<pre><code>code_calculation_defaults = {'mrcc': {'LNO-CCSD(T)': {'calc': 'LNO-CCSD(T)', 'scftype': 'rhf', 'verbosity': 3, 'mem': '2000MB', 'symm': 'off', 'unit': 'angs', 'scfiguess': 'small', 'scfmaxit': 1000, 'scfalg': 'locfit1', 'lcorthr': 'tight', 'bpedo': 0.99999, 'ccmaxit': 400, 'usedisk': 0, 'ccsdalg': 'dfdirect', 'ccsdthreads': 4, 'ccsdmkl': 'thr', 'ptthreads': 4}, 'CCSD(T)': {'calc': 'DF-CCSD(T)', 'scftype': 'rhf', 'verbosity': 3, 'mem': '2000MB', 'symm': 'off', 'unit': 'angs', 'scfiguess': 'small', 'scfmaxit': 1000, 'ccmaxit': 400, 'ccsdalg': 'dfdirect', 'ccsdthreads': 4, 'ccsdmkl': 'thr', 'ptthreads': 4}, 'MP2': {'calc': 'DF-MP2', 'scftype': 'rhf', 'verbosity': 3, 'mem': '2000MB', 'symm': 'off', 'unit': 'angs', 'scfiguess': 'small', 'scfmaxit': 1000, 'scfalg': 'locfit1'}, 'LMP2': {'calc': 'LMP2', 'scftype': 'rhf', 'verbosity': 3, 'mem': '2000MB', 'symm': 'off', 'unit': 'angs', 'lcorthr': 'tight', 'bpedo': 0.99999, 'scfiguess': 'small', 'scfmaxit': 1000, 'scfalg': 'locfit1'}, 'Other': {'verbosity': 3, 'mem': '2000MB', 'symm': 'off', 'unit': 'angs', 'scfiguess': 'small'}}, 'orca': {'orcasimpleinput': {'MP2': 'TightSCF RI-MP2 TightPNO RIJCOSX DIIS', 'DLPNO-CCSD(T)': 'TightSCF DLPNO-CCSD(T) TightPNO RIJCOSX DIIS', 'DLPNO-MP2': 'TightSCF DLPNO-MP2 TightPNO RIJCOSX DIIS', 'CCSD(T)': 'TightSCF CCSD(T) RIJCOSX DIIS', 'Other': 'TightSCF RIJCOSX DIIS'}, 'orcablocks': '\\n%pal nprocs 1 end\\n%maxcore 2000\\n%method\\nMethod hf\\nRI on\\nRunTyp Energy\\nend\\n%scf\\nHFTyp rhf\\nSCFMode Direct\\nsthresh 1e-6\\nAutoTRAHIter 60\\nMaxIter 1000\\nend\\n'}}\n</code></pre>"},{"location":"reference/autoSKZCAM/data.html#autoSKZCAM.data.element_from_atomic_num_dict","title":"element_from_atomic_num_dict  <code>module-attribute</code>","text":"<pre><code>element_from_atomic_num_dict = {v: _ofor (k, v) in items()}\n</code></pre>"},{"location":"reference/autoSKZCAM/data.html#autoSKZCAM.data.frozen_core_defaults","title":"frozen_core_defaults  <code>module-attribute</code>","text":"<pre><code>frozen_core_defaults = {'semicore': {element_from_atomic_num_dict[x]: 0 if x &lt;= 4 else 2 if x &lt;= 12 else 10 if x &lt;= 30 else 18 if x &lt;= 38 else 28 if x &lt;= 48 else 36 if x &lt;= 71 else 46 if x &lt;= 80 else 68 if x &lt;= 103 else Nonefor x in range(1, 104) if x in element_from_atomic_num_dict}, 'valence': {element_from_atomic_num_dict[x]: 0 if x &lt;= 2 else 2 if x &lt;= 10 else 10 if x &lt;= 18 else 18 if x &lt;= 30 else 28 if x &lt;= 36 else 36 if x &lt;= 48 else 46 if x &lt;= 54 else 54 if x &lt;= 70 else 68 if x &lt;= 80 else 78 if x &lt;= 86 else 86 if x &lt;= 102 else 100 if x &lt;= 103 else Nonefor x in range(1, 104) if x in element_from_atomic_num_dict}}\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html","title":"embed","text":""},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.has_chemshell","title":"has_chemshell  <code>module-attribute</code>","text":"<pre><code>has_chemshell = find_spec('chemsh') is not None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster","title":"CreateEmbeddedCluster","text":"<pre><code>CreateEmbeddedCluster(adsorbate_indices: list[int], slab_center_indices: list[int], atom_oxi_states: dict[str, int], adsorbate_slab_file: str | Path, pun_filepath: str | Path | None = None)\n</code></pre> <p>A class to create the quantum clusters and ECP regions for the SKZCAM protocol.</p> <p>Parameters:</p> <ul> <li> <code>adsorbate_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms that make up the adsorbate molecule.</p> </li> <li> <code>slab_center_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.</p> </li> <li> <code>atom_oxi_states</code>               (<code>dict[str, int]</code>)           \u2013            <p>A dictionary with the element symbol as the key and its oxidation state as the value.</p> </li> <li> <code>adsorbate_slab_file</code>               (<code>str | Path</code>)           \u2013            <p>The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.</p> </li> <li> <code>pun_filepath</code>               (<code>str | Path | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex. This file should be generated by ChemShell. If it is None, then ChemShell wil be used to create this file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/embed.py</code> <pre><code>def __init__(\n    self,\n    adsorbate_indices: list[int],\n    slab_center_indices: list[int],\n    atom_oxi_states: dict[str, int],\n    adsorbate_slab_file: str | Path,\n    pun_filepath: str | Path | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the CreateEmbeddedCluster class with the necessary information to create the quantum clusters and ECP regions for the SKZCAM protocol.\n\n    Parameters\n    ----------\n    adsorbate_indices\n        The indices of the atoms that make up the adsorbate molecule.\n    slab_center_indices\n        The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.\n    atom_oxi_states\n        A dictionary with the element symbol as the key and its oxidation state as the value.\n    adsorbate_slab_file\n        The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.\n    pun_filepath\n        The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex. This file should be generated by ChemShell. If it is None, then ChemShell wil be used to create this file.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    self.adsorbate_indices = adsorbate_indices\n    self.slab_center_indices = slab_center_indices\n    self.slab_indices = None  # This will be set later\n    self.atom_oxi_states = atom_oxi_states\n    self.adsorbate_slab_file = adsorbate_slab_file\n    self.pun_filepath = pun_filepath\n\n    # Initialize the skzcam_calcs dictionary to store the calculator information for each SKZCAM cluster\n    self.skzcam_calcs: dict[int, dict[str, CalculatorInfo]] | None = None\n\n    # Initialize the OniomInfo dictionary to store the information for each ONIOM layer\n    self.OniomInfo: dict[str, dict[Literal[\"ll\", \"hl\"], OniomLayerInfo]] | None = (\n        None\n    )\n\n    # Check that the adsorbate_indices and slab_center_indices are not the same\n    if any(x in self.adsorbate_indices for x in self.slab_center_indices):\n        raise ValueError(\n            \"The adsorbate and slab center indices cannot be the same.\"\n        )\n\n    # Initialize the adsorbate, slab and adsorbate_slab Atoms object which contains the adsorbate, slab and adsorbate-slab complex respectively\n    self.adsorbate: Atoms | None\n    self.slab: Atoms | None\n    self.adsorbate_slab: Atoms | None\n\n    # Initialize the embedded_adsorbate_slab_cluster, and embedded_slab_cluster Atoms object which are the embedded cluster for the adsorbate-slab complex and slab respectively\n    self.adsorbate_slab_embedded_cluster: Atoms | None = None\n    self.slab_embedded_cluster: Atoms | None = None\n\n    # Initialize the quantum cluster indices and ECP region indices\n    self.quantum_cluster_indices_set: list[list[int]] | None = None\n    self.ecp_region_indices_set: list[list[int]] | None = None\n\n    # Read the file containing the periodic slab and adsorbate (geometry optimized) and format the resulting Atoms object to be used to create a .pun file in ChemShell.\n\n    # Get the necessary information for the cluster from a provided slab file (in any format that ASE can read)\n    adsorbate_slab = read(self.adsorbate_slab_file)\n\n    # Find indices (within adsorbate_slab) of the slab\n    slab_indices = self.slab_center_indices + [\n        i\n        for i, _ in enumerate(adsorbate_slab)\n        if i not in (self.adsorbate_indices + self.slab_center_indices)\n    ]\n\n    # Create adsorbate and slab from adsorbate_slab\n    slab = adsorbate_slab[slab_indices]\n    adsorbate = adsorbate_slab[self.adsorbate_indices]\n\n    adsorbate.translate(-slab[0].position)\n    slab.translate(-slab[0].position)\n\n    # Get the relative distance of the adsorbate from the first center atom of the slab as defined in the slab_center_indices\n    adsorbate_vector_from_slab = adsorbate[0].position - slab[0].position\n\n    # Get the center of the cluster from the slab_center_indices\n    slab_center_position = slab[\n        : len(self.slab_center_indices)\n    ].get_positions().sum(axis=0) / len(self.slab_center_indices)\n\n    # Add the height of the adsorbate from the slab along the z-direction relative to the slab_center\n    adsorbate_com_z_disp = (\n        adsorbate.get_center_of_mass()[2] - slab_center_position[2]\n    )\n\n    center_position = (\n        np.array([0.0, 0.0, adsorbate_com_z_disp]) + slab_center_position\n    )\n\n    self.adsorbate = adsorbate\n    self.slab = slab\n    self.adsorbate_slab = adsorbate_slab\n    self.adsorbate_vector_from_slab = adsorbate_vector_from_slab\n    self.center_position = center_position\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.OniomInfo","title":"OniomInfo  <code>instance-attribute</code>","text":"<pre><code>OniomInfo: dict[str, dict[Literal['ll', 'hl'], OniomLayerInfo]] | None = None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.adsorbate","title":"adsorbate  <code>instance-attribute</code>","text":"<pre><code>adsorbate: Atoms | None = adsorbate\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.adsorbate_indices","title":"adsorbate_indices  <code>instance-attribute</code>","text":"<pre><code>adsorbate_indices = adsorbate_indices\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.adsorbate_slab","title":"adsorbate_slab  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab: Atoms | None = adsorbate_slab\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.adsorbate_slab_embedded_cluster","title":"adsorbate_slab_embedded_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_embedded_cluster: Atoms | None = None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.adsorbate_slab_file","title":"adsorbate_slab_file  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_file = adsorbate_slab_file\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.adsorbate_vector_from_slab","title":"adsorbate_vector_from_slab  <code>instance-attribute</code>","text":"<pre><code>adsorbate_vector_from_slab = adsorbate_vector_from_slab\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.atom_oxi_states","title":"atom_oxi_states  <code>instance-attribute</code>","text":"<pre><code>atom_oxi_states = atom_oxi_states\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.center_position","title":"center_position  <code>instance-attribute</code>","text":"<pre><code>center_position = center_position\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.ecp_region_indices_set","title":"ecp_region_indices_set  <code>instance-attribute</code>","text":"<pre><code>ecp_region_indices_set: list[list[int]] | None = None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.pun_filepath","title":"pun_filepath  <code>instance-attribute</code>","text":"<pre><code>pun_filepath = pun_filepath\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.quantum_cluster_indices_set","title":"quantum_cluster_indices_set  <code>instance-attribute</code>","text":"<pre><code>quantum_cluster_indices_set: list[list[int]] | None = None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.skzcam_calcs","title":"skzcam_calcs  <code>instance-attribute</code>","text":"<pre><code>skzcam_calcs: dict[int, dict[str, CalculatorInfo]] | None = None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.slab","title":"slab  <code>instance-attribute</code>","text":"<pre><code>slab: Atoms | None = slab\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.slab_center_indices","title":"slab_center_indices  <code>instance-attribute</code>","text":"<pre><code>slab_center_indices = slab_center_indices\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.slab_embedded_cluster","title":"slab_embedded_cluster  <code>instance-attribute</code>","text":"<pre><code>slab_embedded_cluster: Atoms | None = None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.slab_indices","title":"slab_indices  <code>instance-attribute</code>","text":"<pre><code>slab_indices = None\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.run_chemshell","title":"run_chemshell","text":"<pre><code>run_chemshell(filepath: str | Path, chemsh_radius_active: float = 40.0, chemsh_radius_cluster: float = 60.0, chemsh_bq_layer: float = 6.0, write_xyz_file: bool = False) -&gt; None\n</code></pre> <p>Run ChemShell to create an embedded cluster from a slab.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str | Path</code>)           \u2013            <p>The location where the ChemShell output files will be written.</p> </li> <li> <code>chemsh_radius_active</code>               (<code>float</code>, default:                   <code>40.0</code> )           \u2013            <p>The radius of the active region in Angstroms. This 'active' region is simply region where the charge fitting is performed to ensure correct Madelung potential; it can be a relatively large value.</p> </li> <li> <code>chemsh_radius_cluster</code>               (<code>float</code>, default:                   <code>60.0</code> )           \u2013            <p>The radius of the total embedded cluster in Angstroms.</p> </li> <li> <code>chemsh_bq_layer</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>The height above the surface to place some additional fitting point charges in Angstroms; simply for better reproduction of the electrostatic potential close to the adsorbate.</p> </li> <li> <code>write_xyz_file</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to write an XYZ file of the cluster for visualisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/embed.py</code> <pre><code>@requires(has_chemshell, \"ChemShell is not installed\")\ndef run_chemshell(\n    self,\n    filepath: str | Path,\n    chemsh_radius_active: float = 40.0,\n    chemsh_radius_cluster: float = 60.0,\n    chemsh_bq_layer: float = 6.0,\n    write_xyz_file: bool = False,\n) -&gt; None:\n    \"\"\"\n    Run ChemShell to create an embedded cluster from a slab.\n\n    Parameters\n    ----------\n    filepath\n        The location where the ChemShell output files will be written.\n    chemsh_radius_active\n        The radius of the active region in Angstroms. This 'active' region is simply region where the charge fitting is performed to ensure correct Madelung potential; it can be a relatively large value.\n    chemsh_radius_cluster\n        The radius of the total embedded cluster in Angstroms.\n    chemsh_bq_layer\n        The height above the surface to place some additional fitting point charges in Angstroms; simply for better reproduction of the electrostatic potential close to the adsorbate.\n    write_xyz_file\n        Whether to write an XYZ file of the cluster for visualisation.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    from chemsh.io.tools import convert_atoms_to_frag  # noqa: PLC0415\n\n    # Convert ASE Atoms to ChemShell Fragment object\n    slab_frag = convert_atoms_to_frag(\n        self.slab, connect_mode=\"ionic\", dim=\"2D\", ndimensions=2\n    )\n\n    # Add the atomic charges to the fragment\n    slab_frag.addCharges(self.atom_oxi_states)\n\n    # Create the chemshell cluster (i.e., add electrostatic fitting charges) from the fragment\n    chemsh_slab_embedded_cluster = slab_frag.construct_cluster(\n        origin=0,\n        radius_cluster=chemsh_radius_cluster / Bohr,\n        radius_active=chemsh_radius_active / Bohr,\n        bq_layer=chemsh_bq_layer / Bohr,\n        adjust_charge=\"coordination_scaled\",\n    )\n\n    # Save the final cluster to a .pun file\n    chemsh_slab_embedded_cluster.save(\n        filename=Path(filepath).with_suffix(\".pun\"), fmt=\"pun\"\n    )\n    self.pun_filepath = Path(filepath).with_suffix(\".pun\")\n\n    if write_xyz_file:\n        # XYZ for visualisation\n        chemsh_slab_embedded_cluster.save(\n            filename=Path(filepath).with_suffix(\".xyz\"), fmt=\"xyz\"\n        )\n</code></pre>"},{"location":"reference/autoSKZCAM/embed.html#autoSKZCAM.embed.CreateEmbeddedCluster.run_skzcam","title":"run_skzcam","text":"<pre><code>run_skzcam(shell_max: int = 10, shell_width: float = 0.1, bond_dist: float = 2.5, ecp_dist: float = 6.0, write_clusters: bool = False, write_clusters_path: str | Path = '.', write_include_ecp: bool = False) -&gt; SkzcamOutput\n</code></pre> <p>From a provided .pun file (generated by ChemShell), this function creates quantum clusters using the SKZCAM protocol. It will return the embedded cluster Atoms object and the indices of the atoms in the quantum clusters and the ECP region. The number of clusters created is controlled by the rdf_max parameter.</p> <p>Parameters:</p> <ul> <li> <code>shell_max</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of quantum clusters to be created.</p> </li> <li> <code>shell_width</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Defines the distance between atoms within shells; this is the maximum distance between any two atoms within the shell.</p> </li> <li> <code>bond_dist</code>               (<code>float</code>, default:                   <code>2.5</code> )           \u2013            <p>The distance within which an anion is considered to be coordinating a cation.</p> </li> <li> <code>ecp_dist</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>The distance from edges of the quantum cluster to define the ECP region.</p> </li> <li> <code>write_clusters</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the quantum clusters will be written to a file.</p> </li> <li> <code>write_clusters_path</code>               (<code>str | Path</code>, default:                   <code>'.'</code> )           \u2013            <p>The path to the file where the quantum clusters will be written.</p> </li> <li> <code>write_include_ecp</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the ECP region will be included in the quantum clusters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Atoms]</code>           \u2013            <p>A dictionary containing the embedded cluster Atoms object of the adsorbate-slab complex, accessed by the key 'adsorbate_slab_embedded_cluster', and the indices of the atoms in the quantum clusters and the ECP region, accessed by the keys 'quantum_cluster_indices_set' and 'ecp_region_indices_set' respectively.</p> </li> </ul> Source code in <code>autoSKZCAM/embed.py</code> <pre><code>def run_skzcam(\n    self,\n    shell_max: int = 10,\n    shell_width: float = 0.1,\n    bond_dist: float = 2.5,\n    ecp_dist: float = 6.0,\n    write_clusters: bool = False,\n    write_clusters_path: str | Path = \".\",\n    write_include_ecp: bool = False,\n) -&gt; SkzcamOutput:\n    \"\"\"\n    From a provided .pun file (generated by ChemShell), this function creates quantum clusters using the SKZCAM protocol. It will return the embedded cluster Atoms object and the indices of the atoms in the quantum clusters and the ECP region. The number of clusters created is controlled by the rdf_max parameter.\n\n    Parameters\n    ----------\n    shell_max\n        The maximum number of quantum clusters to be created.\n    shell_width\n        Defines the distance between atoms within shells; this is the maximum distance between any two atoms within the shell.\n    bond_dist\n        The distance within which an anion is considered to be coordinating a cation.\n    ecp_dist\n        The distance from edges of the quantum cluster to define the ECP region.\n    write_clusters\n        If True, the quantum clusters will be written to a file.\n    write_clusters_path\n        The path to the file where the quantum clusters will be written.\n    write_include_ecp\n        If True, the ECP region will be included in the quantum clusters.\n\n    Returns\n    -------\n    dict[str, Atoms]\n        A dictionary containing the embedded cluster Atoms object of the adsorbate-slab complex, accessed by the key 'adsorbate_slab_embedded_cluster', and the indices of the atoms in the quantum clusters and the ECP region, accessed by the keys 'quantum_cluster_indices_set' and 'ecp_region_indices_set' respectively.\n    \"\"\"\n\n    # Read the .pun file and create the embedded_cluster Atoms object\n    self.slab_embedded_cluster = self._convert_pun_to_atoms(\n        pun_filepath=self.pun_filepath\n    )\n\n    # Get distances of all atoms from the cluster center\n    atom_center_distances = _get_atom_distances(\n        atoms=self.slab_embedded_cluster, center_position=self.center_position\n    )\n\n    # Determine the cation shells from the center of the embedded cluster\n    _, cation_shells_idx = self._find_cation_shells(\n        slab_embedded_cluster=self.slab_embedded_cluster,\n        distances=atom_center_distances,\n        shell_width=shell_width,\n    )\n\n    # Create the distance matrix for the embedded cluster\n    slab_embedded_cluster_all_dist = self.slab_embedded_cluster.get_all_distances()\n\n    # Create the anion coordination list for each cation shell\n    anion_coord_idx = []\n    for shell_idx in range(shell_max):\n        shell_indices = cation_shells_idx[shell_idx]\n        anion_coord_idx += [\n            self._get_anion_coordination(\n                slab_embedded_cluster=self.slab_embedded_cluster,\n                cation_shell_indices=shell_indices,\n                dist_matrix=slab_embedded_cluster_all_dist,\n                bond_dist=bond_dist,\n            )\n        ]\n\n    # Create the quantum clusters by summing up the indices of the cations and their coordinating anions\n    slab_quantum_cluster_indices_set = []\n    dummy_cation_indices = []\n    dummy_anion_indices = []\n    for shell_idx in range(shell_max):\n        dummy_cation_indices += cation_shells_idx[shell_idx]\n        dummy_anion_indices += anion_coord_idx[shell_idx]\n        slab_quantum_cluster_indices_set += [\n            list(set(dummy_cation_indices + dummy_anion_indices))\n        ]\n\n    # Get the ECP region for each quantum cluster\n    slab_ecp_region_indices_set = self._get_ecp_region(\n        slab_embedded_cluster=self.slab_embedded_cluster,\n        quantum_cluster_indices_set=slab_quantum_cluster_indices_set,\n        dist_matrix=slab_embedded_cluster_all_dist,\n        ecp_dist=ecp_dist,\n    )\n\n    # Create the adsorbate_slab_embedded_cluster from slab_embedded_cluster and adsorbate atoms objects. This also sets the final quantum_cluster_indices_set and ecp_region_indices_set for the adsorbate_slab_embedded_cluster\n    self._create_adsorbate_slab_embedded_cluster(\n        quantum_cluster_indices_set=slab_quantum_cluster_indices_set,\n        ecp_region_indices_set=slab_ecp_region_indices_set,\n    )\n\n    # Write the quantum clusters to files\n    if write_clusters:\n        for idx in range(len(self.quantum_cluster_indices_set)):\n            quantum_atoms = self.adsorbate_slab_embedded_cluster[\n                self.quantum_cluster_indices_set[idx]\n            ]\n            if write_include_ecp:\n                ecp_atoms = self.adsorbate_slab_embedded_cluster[\n                    self.ecp_region_indices_set[idx]\n                ]\n                ecp_atoms.set_chemical_symbols(np.array([\"U\"] * len(ecp_atoms)))\n                cluster_atoms = quantum_atoms + ecp_atoms\n            else:\n                cluster_atoms = quantum_atoms\n\n            cluster_atoms.set_pbc(False)\n            cluster_atoms.set_cell([0, 0, 0])\n            write(\n                Path(write_clusters_path, f\"SKZCAM_cluster_{idx}.xyz\"),\n                cluster_atoms,\n            )\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html","title":"io","text":"<p>Input and output functions for MRCC and ORCA.</p>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator","title":"MRCCInputGenerator","text":"<pre><code>MRCCInputGenerator(adsorbate_slab_embedded_cluster: Atoms, quantum_cluster_indices: list[int], ecp_region_indices: list[int], element_info: dict[ElementStr, ElementInfo], include_cp: bool = True, multiplicities: MultiplicityDict | None = None)\n</code></pre> <p>A class to generate the inputs necessary to perform SKZCAM calculators for the MRCC ASE calculator found in QuAcc.</p> <p>Parameters:</p> <ul> <li> <code>adsorbate_slab_embedded_cluster</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object containing the atomic coordinates and atomic charges from the .pun file, as well as the atom type. This object is created within the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> </li> <li> <code>quantum_cluster_indices</code>               (<code>list[int]</code>)           \u2013            <p>A list containing the indices of the atoms in one quantum cluster. These indices are created within the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> </li> <li> <code>ecp_region_indices</code>               (<code>list[int]</code>)           \u2013            <p>A list containing the indices of the atoms in the corresponding ECP region of one quantum cluster. These indices are provided by the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> </li> <li> <code>element_info</code>               (<code>dict[ElementStr, ElementInfo]</code>)           \u2013            <p>A dictionary with elements as keys which gives the (1) number of core electrons as <code>core</code>, (2) basis set as <code>basis</code>, (3) effective core potential as <code>ecp</code>, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as <code>ri_scf_basis</code> and (5) resolution-of-identity/density-fitting for correlated wave-function methods as <code>ri_cwft_basis</code>.</p> </li> <li> <code>include_cp</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the coords strings will include the counterpoise correction (i.e., ghost atoms) for the adsorbate and slab.</p> </li> <li> <code>multiplicities</code>               (<code>MultiplicityDict | None</code>, default:                   <code>None</code> )           \u2013            <p>The multiplicity of the adsorbate-slab complex, adsorbate and slab respectively, with the keys <code>adsorbate_slab</code>, <code>adsorbate</code>, and <code>slab</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/io.py</code> <pre><code>def __init__(\n    self,\n    adsorbate_slab_embedded_cluster: Atoms,\n    quantum_cluster_indices: list[int],\n    ecp_region_indices: list[int],\n    element_info: dict[ElementStr, ElementInfo],\n    include_cp: bool = True,\n    multiplicities: MultiplicityDict | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the MRCCInputGenerator class.\n\n    Parameters\n    ----------\n    adsorbate_slab_embedded_cluster\n        The ASE Atoms object containing the atomic coordinates and atomic charges from the .pun file, as well as the atom type. This object is created within the [autoSKZCAM.embed.CreateEmbeddedCluster][] class.\n    quantum_cluster_indices\n        A list containing the indices of the atoms in one quantum cluster. These indices are created within the [autoSKZCAM.embed.CreateEmbeddedCluster][] class.\n    ecp_region_indices\n        A list containing the indices of the atoms in the corresponding ECP region of one quantum cluster. These indices are provided by the [autoSKZCAM.embed.CreateEmbeddedCluster][] class.\n    element_info\n        A dictionary with elements as keys which gives the (1) number of core electrons as `core`, (2) basis set as `basis`, (3) effective core potential as `ecp`, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as `ri_scf_basis` and (5) resolution-of-identity/density-fitting for correlated wave-function methods as `ri_cwft_basis`.\n    include_cp\n        If True, the coords strings will include the counterpoise correction (i.e., ghost atoms) for the adsorbate and slab.\n    multiplicities\n        The multiplicity of the adsorbate-slab complex, adsorbate and slab respectively, with the keys `adsorbate_slab`, `adsorbate`, and `slab`.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    self.adsorbate_slab_embedded_cluster = adsorbate_slab_embedded_cluster\n    self.quantum_cluster_indices = quantum_cluster_indices\n    self.ecp_region_indices = ecp_region_indices\n    self.element_info = element_info\n    self.include_cp = include_cp\n    self.multiplicities = (\n        {\"adsorbate_slab\": 1, \"adsorbate\": 1, \"slab\": 1}\n        if multiplicities is None\n        else multiplicities\n    )\n\n    # Check that none of the indices in quantum_cluster_indices are in ecp_region_indices\n    if not np.all(\n        [x not in self.ecp_region_indices for x in self.quantum_cluster_indices]\n    ):\n        raise ValueError(\n            \"An atom in the quantum cluster is also in the ECP region.\"\n        )\n\n    # Create the adsorbate-slab complex quantum cluster and ECP region cluster\n    self.adsorbate_slab_cluster: Atoms = self.adsorbate_slab_embedded_cluster[\n        self.quantum_cluster_indices\n    ]\n    self.ecp_region: Atoms = self.adsorbate_slab_embedded_cluster[\n        self.ecp_region_indices\n    ]\n\n    # Get the indices of the adsorbates from the quantum cluster\n    self.adsorbate_indices: list[int] = [\n        i\n        for i in range(len(self.adsorbate_slab_cluster))\n        if self.adsorbate_slab_cluster.get_array(\"atom_type\")[i] == \"adsorbate\"\n    ]\n    # Get the indices of the slab from the quantum cluster\n    self.slab_indices: list[int] = [\n        i\n        for i in range(len(self.adsorbate_slab_cluster))\n        if self.adsorbate_slab_cluster.get_array(\"atom_type\")[i] != \"adsorbate\"\n    ]\n\n    # Create the adsorbate and slab quantum clusters\n    self.adsorbate_cluster: Atoms = self.adsorbate_slab_cluster[\n        self.adsorbate_indices\n    ]\n    self.slab_cluster: Atoms = self.adsorbate_slab_cluster[self.slab_indices]\n\n    # Initialize the SKZCAM MRCC input strings for the adsorbate-slab complex, adsorbate, and slab in the same fashion as for ORCAInputGenerator.orcablocks\n    self.skzcam_input_str: BlockInfo = {\n        \"adsorbate_slab\": \"\",\n        \"adsorbate\": \"\",\n        \"slab\": \"\",\n    }\n\n    # Initialize the dictionary with keyword and values pairs for MRCC input\n    self.skzcam_input_dict: MrccInputDict = {\n        \"adsorbate_slab\": {},\n        \"adsorbate\": {},\n        \"slab\": {},\n    }\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.adsorbate_cluster","title":"adsorbate_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_cluster: Atoms = adsorbate_slab_cluster[adsorbate_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.adsorbate_indices","title":"adsorbate_indices  <code>instance-attribute</code>","text":"<pre><code>adsorbate_indices: list[int] = [i for i in range(len(adsorbate_slab_cluster)) if get_array('atom_type')[i] == 'adsorbate']\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.adsorbate_slab_cluster","title":"adsorbate_slab_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_cluster: Atoms = adsorbate_slab_embedded_cluster[quantum_cluster_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.adsorbate_slab_embedded_cluster","title":"adsorbate_slab_embedded_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_embedded_cluster = adsorbate_slab_embedded_cluster\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.ecp_region","title":"ecp_region  <code>instance-attribute</code>","text":"<pre><code>ecp_region: Atoms = adsorbate_slab_embedded_cluster[ecp_region_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.ecp_region_indices","title":"ecp_region_indices  <code>instance-attribute</code>","text":"<pre><code>ecp_region_indices = ecp_region_indices\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.element_info","title":"element_info  <code>instance-attribute</code>","text":"<pre><code>element_info = element_info\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.include_cp","title":"include_cp  <code>instance-attribute</code>","text":"<pre><code>include_cp = include_cp\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.multiplicities","title":"multiplicities  <code>instance-attribute</code>","text":"<pre><code>multiplicities = {'adsorbate_slab': 1, 'adsorbate': 1, 'slab': 1} if multiplicities is None else multiplicities\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.quantum_cluster_indices","title":"quantum_cluster_indices  <code>instance-attribute</code>","text":"<pre><code>quantum_cluster_indices = quantum_cluster_indices\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.skzcam_input_dict","title":"skzcam_input_dict  <code>instance-attribute</code>","text":"<pre><code>skzcam_input_dict: MrccInputDict = {'adsorbate_slab': {}, 'adsorbate': {}, 'slab': {}}\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.skzcam_input_str","title":"skzcam_input_str  <code>instance-attribute</code>","text":"<pre><code>skzcam_input_str: BlockInfo = {'adsorbate_slab': '', 'adsorbate': '', 'slab': ''}\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.slab_cluster","title":"slab_cluster  <code>instance-attribute</code>","text":"<pre><code>slab_cluster: Atoms = adsorbate_slab_cluster[slab_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.slab_indices","title":"slab_indices  <code>instance-attribute</code>","text":"<pre><code>slab_indices: list[int] = [i for i in range(len(adsorbate_slab_cluster)) if get_array('atom_type')[i] != 'adsorbate']\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.create_genbas_file","title":"create_genbas_file","text":"<pre><code>create_genbas_file() -&gt; str\n</code></pre> <p>Create a GENBAS file that can be read by MRCC. This contains the capped ECP in CFOUR format as well as empty basis sets for the capped ECP.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The text for the GENBAS file for the electrostatic embedding.</p> </li> </ul> Source code in <code>autoSKZCAM/io.py</code> <pre><code>def create_genbas_file(self) -&gt; str:\n    \"\"\"\n    Create a GENBAS file that can be read by MRCC. This contains the capped ECP in CFOUR format as well as empty basis sets for the capped ECP.\n\n    Returns\n    -------\n    str\n        The text for the GENBAS file for the electrostatic embedding.\n    \"\"\"\n    # Get set of element symbols from the ecp_region\n    element_symbols = list(set(self.ecp_region.get_chemical_symbols()))\n\n    genbas_file = \"\"\n    for element in element_symbols:\n        genbas_file += f\"{element}:cappedECP\\nINSERT_cappedECP\\n\\n\"\n        genbas_file += f\"{element}:no-basis-set\\nno basis set\\n\\n    0\\n    0\\n    0\\n    0\\n\\n\"\n        genbas_file += f\"{element}:no-basis-set-ri-jk\\nno basis set\\n\\n    0\\n    0\\n    0\\n    0\\n\\n\"\n\n    return genbas_file\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.MRCCInputGenerator.generate_input","title":"generate_input","text":"<pre><code>generate_input() -&gt; MrccInputDict\n</code></pre> <p>Creates the mrccinput input for the MRCC ASE calculator.</p> <p>Returns:</p> <ul> <li> <code>MrccInputDict</code>           \u2013            <p>A dictionary of key-value pairs (to be put in 'mrccinput' parameter) for the adsorbate-slab complex, the adsorbate, and the slab.</p> </li> </ul> Source code in <code>autoSKZCAM/io.py</code> <pre><code>def generate_input(self) -&gt; MrccInputDict:\n    \"\"\"\n    Creates the mrccinput input for the MRCC ASE calculator.\n\n    Returns\n    -------\n    MrccInputDict\n        A dictionary of key-value pairs (to be put in 'mrccinput' parameter) for the adsorbate-slab complex, the adsorbate, and the slab.\n    \"\"\"\n\n    def _convert_input_str_to_dict(input_str: str) -&gt; dict[str, str]:\n        \"\"\"\n        Convert the SKZCAM input string to a dictionary.\n\n        Parameters\n        ----------\n        input_str\n            The SKZCAM input string containing all the input parameters for the SKZCAM protocol (i.e., basis, ecp, geometry, point charges)\n\n        Returns\n        -------\n        dict[str,str]\n            The SKZCAM input as a dictionary where each key is the input parameter and the value is the value of that parameter.\n        \"\"\"\n\n        input_dict = {}\n\n        key = None\n\n        for line in input_str.split(\"\\n\"):\n            if \"=\" in line:\n                key = line.split(\"=\")[0]\n                input_dict[key] = line.split(\"=\")[1]\n            elif key is not None:\n                input_dict[key] += \"\\n\" + line\n\n        return input_dict\n\n    # Create the blocks for the basis sets (basis, basis_sm, dfbasis_scf, dfbasis_cor, ecp)\n    self._generate_basis_ecp_block()\n\n    # Create the blocks for the coordinates\n    self._generate_coords_block()\n\n    # Create the point charge block and add it to the adsorbate-slab complex and slab blocks\n    point_charge_block = self._generate_point_charge_block()\n    self.skzcam_input_str[\"adsorbate_slab\"] += point_charge_block\n    self.skzcam_input_str[\"slab\"] += point_charge_block\n\n    # Convert the input string to a dictionary\n    self.skzcam_input_dict[\"adsorbate_slab\"] = _convert_input_str_to_dict(\n        self.skzcam_input_str[\"adsorbate_slab\"]\n    )\n    self.skzcam_input_dict[\"adsorbate\"] = _convert_input_str_to_dict(\n        self.skzcam_input_str[\"adsorbate\"]\n    )\n    self.skzcam_input_dict[\"slab\"] = _convert_input_str_to_dict(\n        self.skzcam_input_str[\"slab\"]\n    )\n\n    return self.skzcam_input_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator","title":"ORCAInputGenerator","text":"<pre><code>ORCAInputGenerator(adsorbate_slab_embedded_cluster: Atoms, quantum_cluster_indices: list[int], ecp_region_indices: list[int], element_info: dict[ElementStr, ElementInfo], include_cp: bool = True, multiplicities: MultiplicityDict | None = None)\n</code></pre> <p>A class to generate the SKZCAM input for the ORCA ASE calculator.</p> <p>Parameters:</p> <ul> <li> <code>adsorbate_slab_embedded_cluster</code>               (<code>Atoms</code>)           \u2013            <p>The ASE Atoms object containing the atomic coordinates and atomic charges from the .pun file, as well as the atom type. This object is created by the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> </li> <li> <code>quantum_cluster_indices</code>               (<code>list[int]</code>)           \u2013            <p>A list containing the indices of the atoms in each quantum cluster. These indices are provided by the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> </li> <li> <code>ecp_region_indices</code>               (<code>list[int]</code>)           \u2013            <p>A list containing the indices of the atoms in each ECP region. These indices are provided by the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> </li> <li> <code>element_info</code>               (<code>dict[ElementStr, ElementInfo]</code>)           \u2013            <p>A dictionary with elements as keys which gives the (1) number of core electrons as <code>core</code>, (2) basis set as <code>basis</code>, (3) effective core potential as <code>ecp</code>, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as <code>ri_scf_basis</code> and (5) resolution-of-identity/density-fitting for correlated wave-function methods as <code>ri_cwft_basis</code>.</p> </li> <li> <code>include_cp</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the coords strings will include the counterpoise correction (i.e., ghost atoms) for the adsorbate and slab.</p> </li> <li> <code>multiplicities</code>               (<code>MultiplicityDict | None</code>, default:                   <code>None</code> )           \u2013            <p>The multiplicity of the adsorbate-slab complex, adsorbate and slab respectively, with the keys <code>adsorbate_slab</code>, <code>adsorbate</code>, and <code>slab</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/io.py</code> <pre><code>def __init__(\n    self,\n    adsorbate_slab_embedded_cluster: Atoms,\n    quantum_cluster_indices: list[int],\n    ecp_region_indices: list[int],\n    element_info: dict[ElementStr, ElementInfo],\n    include_cp: bool = True,\n    multiplicities: MultiplicityDict | None = None,\n) -&gt; None:\n    \"\"\"\n    Initializes the ORCA input generator.\n\n    Parameters\n    ----------\n    adsorbate_slab_embedded_cluster\n        The ASE Atoms object containing the atomic coordinates and atomic charges from the .pun file, as well as the atom type. This object is created by the [autoSKZCAM.embed.CreateEmbeddedCluster][] class.\n    quantum_cluster_indices\n        A list containing the indices of the atoms in each quantum cluster. These indices are provided by the [autoSKZCAM.embed.CreateEmbeddedCluster][] class.\n    ecp_region_indices\n        A list containing the indices of the atoms in each ECP region. These indices are provided by the [autoSKZCAM.embed.CreateEmbeddedCluster][] class.\n    element_info\n        A dictionary with elements as keys which gives the (1) number of core electrons as `core`, (2) basis set as `basis`, (3) effective core potential as `ecp`, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as `ri_scf_basis` and (5) resolution-of-identity/density-fitting for correlated wave-function methods as `ri_cwft_basis`.\n    include_cp\n        If True, the coords strings will include the counterpoise correction (i.e., ghost atoms) for the adsorbate and slab.\n    multiplicities\n        The multiplicity of the adsorbate-slab complex, adsorbate and slab respectively, with the keys `adsorbate_slab`, `adsorbate`, and `slab`.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    self.adsorbate_slab_embedded_cluster = adsorbate_slab_embedded_cluster\n    self.quantum_cluster_indices = quantum_cluster_indices\n    self.ecp_region_indices = ecp_region_indices\n    self.element_info = element_info\n    self.include_cp = include_cp\n    self.multiplicities = (\n        {\"adsorbate_slab\": 1, \"adsorbate\": 1, \"slab\": 1}\n        if multiplicities is None\n        else multiplicities\n    )\n\n    # Check that none of the indices in quantum_cluster_indices are in ecp_region_indices\n    if not np.all(\n        [x not in self.ecp_region_indices for x in self.quantum_cluster_indices]\n    ):\n        raise ValueError(\n            \"An atom in the quantum cluster is also in the ECP region.\"\n        )\n\n    # Create the adsorbate-slab complex quantum cluster and ECP region cluster\n    self.adsorbate_slab_cluster: Atoms = self.adsorbate_slab_embedded_cluster[\n        self.quantum_cluster_indices\n    ]\n    self.ecp_region: Atoms = self.adsorbate_slab_embedded_cluster[\n        self.ecp_region_indices\n    ]\n\n    # Get the indices of the adsorbates from the quantum cluster\n    self.adsorbate_indices: list[int] = [\n        i\n        for i in range(len(self.adsorbate_slab_cluster))\n        if self.adsorbate_slab_cluster.get_array(\"atom_type\")[i] == \"adsorbate\"\n    ]\n    # Get the indices of the slab from the quantum cluster\n    self.slab_indices: list[int] = [\n        i\n        for i in range(len(self.adsorbate_slab_cluster))\n        if self.adsorbate_slab_cluster.get_array(\"atom_type\")[i] != \"adsorbate\"\n    ]\n\n    # Create the adsorbate and slab quantum clusters\n    self.adsorbate_cluster: Atoms = self.adsorbate_slab_cluster[\n        self.adsorbate_indices\n    ]\n    self.slab_cluster: Atoms = self.adsorbate_slab_cluster[self.slab_indices]\n\n    # Initialize the orcablocks input strings for the adsorbate-slab complex, adsorbate, and slab\n    self.orcablocks: BlockInfo = {\"adsorbate_slab\": \"\", \"adsorbate\": \"\", \"slab\": \"\"}\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.adsorbate_cluster","title":"adsorbate_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_cluster: Atoms = adsorbate_slab_cluster[adsorbate_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.adsorbate_indices","title":"adsorbate_indices  <code>instance-attribute</code>","text":"<pre><code>adsorbate_indices: list[int] = [i for i in range(len(adsorbate_slab_cluster)) if get_array('atom_type')[i] == 'adsorbate']\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.adsorbate_slab_cluster","title":"adsorbate_slab_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_cluster: Atoms = adsorbate_slab_embedded_cluster[quantum_cluster_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.adsorbate_slab_embedded_cluster","title":"adsorbate_slab_embedded_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_embedded_cluster = adsorbate_slab_embedded_cluster\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.ecp_region","title":"ecp_region  <code>instance-attribute</code>","text":"<pre><code>ecp_region: Atoms = adsorbate_slab_embedded_cluster[ecp_region_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.ecp_region_indices","title":"ecp_region_indices  <code>instance-attribute</code>","text":"<pre><code>ecp_region_indices = ecp_region_indices\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.element_info","title":"element_info  <code>instance-attribute</code>","text":"<pre><code>element_info = element_info\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.include_cp","title":"include_cp  <code>instance-attribute</code>","text":"<pre><code>include_cp = include_cp\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.multiplicities","title":"multiplicities  <code>instance-attribute</code>","text":"<pre><code>multiplicities = {'adsorbate_slab': 1, 'adsorbate': 1, 'slab': 1} if multiplicities is None else multiplicities\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.orcablocks","title":"orcablocks  <code>instance-attribute</code>","text":"<pre><code>orcablocks: BlockInfo = {'adsorbate_slab': '', 'adsorbate': '', 'slab': ''}\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.quantum_cluster_indices","title":"quantum_cluster_indices  <code>instance-attribute</code>","text":"<pre><code>quantum_cluster_indices = quantum_cluster_indices\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.slab_cluster","title":"slab_cluster  <code>instance-attribute</code>","text":"<pre><code>slab_cluster: Atoms = adsorbate_slab_cluster[slab_indices]\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.slab_indices","title":"slab_indices  <code>instance-attribute</code>","text":"<pre><code>slab_indices: list[int] = [i for i in range(len(adsorbate_slab_cluster)) if get_array('atom_type')[i] != 'adsorbate']\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.create_point_charge_file","title":"create_point_charge_file","text":"<pre><code>create_point_charge_file() -&gt; str\n</code></pre> <p>Create a point charge file that can be read by ORCA. This requires the embedded_cluster Atoms object containing both atom_type and oxi_states arrays, as well as the indices of the quantum cluster and ECP region.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The text for the point charge file for the electrostatic embedding.</p> </li> </ul> Source code in <code>autoSKZCAM/io.py</code> <pre><code>def create_point_charge_file(self) -&gt; str:\n    \"\"\"\n    Create a point charge file that can be read by ORCA. This requires the embedded_cluster Atoms object containing both atom_type and oxi_states arrays, as well as the indices of the quantum cluster and ECP region.\n\n    Returns\n    -------\n    str\n        The text for the point charge file for the electrostatic embedding.\n    \"\"\"\n\n    # Get the oxi_states arrays from the embedded_cluster\n    oxi_states = self.adsorbate_slab_embedded_cluster.get_array(\"oxi_states\")\n\n    # Get the number of point charges for this system\n    total_indices = self.quantum_cluster_indices + self.ecp_region_indices\n    num_pc = len(self.adsorbate_slab_embedded_cluster) - len(total_indices)\n    counter = 0\n    pc_file = f\"{num_pc}\\n\"\n    for i in range(len(self.adsorbate_slab_embedded_cluster)):\n        if i not in total_indices:\n            counter += 1\n            position = self.adsorbate_slab_embedded_cluster[i].position\n            if counter != num_pc:\n                pc_file += f\"{oxi_states[i]:-16.11f} {position[0]:-16.11f} {position[1]:-16.11f} {position[2]:-16.11f}\\n\"\n            else:\n                pc_file += f\"{oxi_states[i]:-16.11f} {position[0]:-16.11f} {position[1]:-16.11f} {position[2]:-16.11f}\"\n    return pc_file\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.ORCAInputGenerator.generate_input","title":"generate_input","text":"<pre><code>generate_input() -&gt; BlockInfo\n</code></pre> <p>Creates the orcablocks input for the ORCA ASE calculator.</p> <p>Returns:</p> <ul> <li> <code>BlockInfo</code>           \u2013            <p>The ORCA input block (to be put in 'orcablocks' parameter) as a string for the adsorbate-slab complex, the adsorbate, and the slab in a dictionary with the keys 'adsorbate_slab', 'adsorbate', and 'slab' respectively.</p> </li> </ul> Source code in <code>autoSKZCAM/io.py</code> <pre><code>def generate_input(self) -&gt; BlockInfo:\n    \"\"\"\n    Creates the orcablocks input for the ORCA ASE calculator.\n\n    Returns\n    -------\n    BlockInfo\n        The ORCA input block (to be put in 'orcablocks' parameter) as a string for the adsorbate-slab complex, the adsorbate, and the slab in a dictionary with the keys 'adsorbate_slab', 'adsorbate', and 'slab' respectively.\n    \"\"\"\n\n    # First generate the preamble block\n    self._generate_preamble_block()\n\n    # Create the blocks for the coordinates\n    self._generate_coords_block()\n\n    # Combine the blocks\n    return self.orcablocks\n</code></pre>"},{"location":"reference/autoSKZCAM/io.html#autoSKZCAM.io.create_atom_coord_string","title":"create_atom_coord_string","text":"<pre><code>create_atom_coord_string(atom: Atom, is_ghost_atom: bool = False, is_capped_ecp: bool = False, pc_charge: float | None = None) -&gt; str\n</code></pre> <p>Creates a string containing the Atom symbol and coordinates for both MRCC and ORCA, with additional information for atoms in the ECP region as well as ghost atoms.</p> <p>Parameters:</p> <ul> <li> <code>atom</code>               (<code>Atom</code>)           \u2013            <p>The ASE Atom (not Atoms) object containing the atomic coordinates.</p> </li> <li> <code>is_ghost_atom</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, then the atom is a ghost atom.</p> </li> <li> <code>is_capped_ecp</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, then the atom is a capped_ECP.</p> </li> <li> <code>pc_charge</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The point charge value for the ECP region atom.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The atom symbol and coordinates in the ORCA input file format.</p> </li> </ul> Source code in <code>autoSKZCAM/io.py</code> <pre><code>def create_atom_coord_string(\n    atom: Atom,\n    is_ghost_atom: bool = False,\n    is_capped_ecp: bool = False,\n    pc_charge: float | None = None,\n) -&gt; str:\n    \"\"\"\n    Creates a string containing the Atom symbol and coordinates for both MRCC and ORCA, with additional information for atoms in the ECP region as well as ghost atoms.\n\n    Parameters\n    ----------\n    atom\n        The ASE Atom (not Atoms) object containing the atomic coordinates.\n    is_ghost_atom\n        If True, then the atom is a ghost atom.\n    is_capped_ecp\n        If True, then the atom is a capped_ECP.\n    pc_charge\n        The point charge value for the ECP region atom.\n\n    Returns\n    -------\n    str\n        The atom symbol and coordinates in the ORCA input file format.\n    \"\"\"\n\n    # If ecp_info is not None and ghost_atom is True, raise an error\n    if is_capped_ecp and is_ghost_atom:\n        raise ValueError(\"Capped ECP cannot be a ghost atom.\")\n\n    # Check that pc_charge is a float if atom_ecp_info is not None\n    if is_capped_ecp and pc_charge is None:\n        raise ValueError(\"Point charge value must be given for atoms with ECP info.\")\n\n    if is_ghost_atom:\n        atom_coord_str = f\"{(atom.symbol + ':').ljust(3)} {' ' * 16} {atom.position[0]:-16.11f} {atom.position[1]:-16.11f} {atom.position[2]:-16.11f}\\n\"\n    elif is_capped_ecp:\n        atom_coord_str = f\"{(atom.symbol + '&gt;').ljust(3)} {pc_charge:-16.11f} {atom.position[0]:-16.11f} {atom.position[1]:-16.11f} {atom.position[2]:-16.11f}\\ncappedECP\\n\"\n    else:\n        atom_coord_str = f\"{atom.symbol.ljust(3)} {' ' * 16} {atom.position[0]:-16.11f} {atom.position[1]:-16.11f} {atom.position[2]:-16.11f}\\n\"\n\n    return atom_coord_str\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html","title":"oniom","text":"<p>Functions for handling ONIOM mechanical embedding.</p>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare","title":"Prepare","text":"<pre><code>Prepare(EmbeddedCluster: CreateEmbeddedCluster, OniomInfo: dict[str, OniomLayerInfo], capped_ecp: dict[Literal['mrcc', 'orca'], str] | None = None, multiplicities: dict[str, int] | None = None, **kwargs)\n</code></pre> <p>From the set of ONIOM calculations, this class generates the calculations needed to be performed for each cluster from the series of clusters generated by the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> <p>Parameters:</p> <ul> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster</code>)           \u2013            <p>The CreateEmbeddedCluster object containing the atomic coordinates and atomic charges from the .pun file, as well as the atom type. This assumes the run_skzcam function has been run.</p> </li> <li> <code>OniomInfo</code>               (<code>dict[str, OniomLayerInfo]</code>)           \u2013            <p>A dictionary containing the information for each of the calculations for each of the ONIOM layers. An arbitrary number of ONIOM layers can be included.</p> </li> <li> <code>capped_ecp</code>               (<code>dict[Literal['mrcc', 'orca'], str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary containing the capped ECPs for each element in the quantum cluster. The dictionary should be in the form of {code: \"capped ecp info\"}. The code should be either 'mrcc' or 'orca'. Refer to the autoSKZCAM.data.capped_ecp_defaults for the default values and how it should be formatted.</p> </li> <li> <code>multiplicities</code>               (<code>dict[str, int] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary containing the multiplicities for the adsorbate, slab and adsorbate-slab complex. The dictionary should be in the form of {<code>adsorbate_slab</code>: int, <code>adsorbate</code>: int, <code>slab</code>: int}.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/oniom.py</code> <pre><code>def __init__(\n    self,\n    EmbeddedCluster: CreateEmbeddedCluster,\n    OniomInfo: dict[str, OniomLayerInfo],\n    capped_ecp: dict[Literal[\"mrcc\", \"orca\"], str] | None = None,\n    multiplicities: dict[str, int] | None = None,\n    **kwargs,  # noqa ARG002\n) -&gt; None:\n    \"\"\"\n    Initialize the Prepare object with the necessary inputs.\n\n    Parameters\n    ----------\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the atomic coordinates and atomic charges from the .pun file, as well as the atom type. This assumes the run_skzcam function has been run.\n    OniomInfo\n        A dictionary containing the information for each of the calculations for each of the ONIOM layers. An arbitrary number of ONIOM layers can be included.\n    capped_ecp\n        A dictionary containing the capped ECPs for each element in the quantum cluster. The dictionary should be in the form of {code: \"capped ecp info\"}. The code should be either 'mrcc' or 'orca'. Refer to the [autoSKZCAM.data.capped_ecp_defaults][] for the default values and how it should be formatted.\n    multiplicities\n        A dictionary containing the multiplicities for the adsorbate, slab and adsorbate-slab complex. The dictionary should be in the form of {`adsorbate_slab`: int, `adsorbate`: int, `slab`: int}.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    if multiplicities is None:\n        multiplicities = {\"adsorbate_slab\": 1, \"adsorbate\": 1, \"slab\": 1}\n    self.adsorbate_slab_embedded_cluster = (\n        EmbeddedCluster.adsorbate_slab_embedded_cluster\n    )\n    self.quantum_cluster_indices_set = EmbeddedCluster.quantum_cluster_indices_set\n    self.ecp_region_indices_set = EmbeddedCluster.ecp_region_indices_set\n    self.OniomInfo = OniomInfo\n    if capped_ecp is None:\n        unformatted_capped_ecp = capped_ecp_defaults\n    else:\n        unformatted_capped_ecp = capped_ecp\n    self.multiplicities = multiplicities\n    self.EmbeddedCluster = EmbeddedCluster\n\n    # Check that adso_slab_embedded_cluster, quantum_cluster_indices_set and ecp_region_indices_set are not None\n    if (\n        self.adsorbate_slab_embedded_cluster is None\n        or self.quantum_cluster_indices_set is None\n        or self.ecp_region_indices_set is None\n    ):\n        raise ValueError(\n            \"The adsorbate_slab_embedded_cluster, quantum_cluster_indices_set and ecp_region_indices_set must be provided.\"\n        )\n\n    # Check that the quantum_cluster_indices_set and ecp_region_indices_set are the same length\n    if len(self.quantum_cluster_indices_set) != len(self.ecp_region_indices_set):\n        raise ValueError(\n            \"The quantum_cluster_indices_set and ecp_region_indices_set must be the same length.\"\n        )\n\n    # Raise an error if the capped_ecp dictionary is not formatted correctly\n    formatted_capped_ecp = {}\n    for code, ecp in unformatted_capped_ecp.items():\n        if code.lower() == \"mrcc\" or code.lower() == \"orca\":\n            formatted_capped_ecp[code.lower()] = ecp\n        else:\n            raise ValueError(\n                \"The keys in the capped_ecp dictionary must be either 'mrcc' or 'orca' in the corresponding code format.\"\n            )\n    self.capped_ecp = formatted_capped_ecp\n\n    # Raise an error if multiplicities is not formatted correctly\n    for structure in [\"adsorbate_slab\", \"adsorbate\", \"slab\"]:\n        if structure not in self.multiplicities:\n            raise ValueError(\n                \"The multiplicities must be provided for all three structures: adsorbate_slab, adsorbate, and slab.\"\n            )\n\n    # Check that all of the necessary keywords are included in each oniom layer\n    max_cluster = 0\n    for layer_name, oniom_layer in self.OniomInfo.items():\n        for level in [\"ll\", \"hl\"]:\n            if oniom_layer[level] is not None:\n                oniom_layer_parameters = oniom_layer[level]\n                # Check that all the required parameters are provided\n                for parameter in [\n                    \"method\",\n                    \"max_cluster_num\",\n                    \"basis\",\n                    \"frozen_core\",\n                    \"code\",\n                ]:\n                    if parameter not in oniom_layer_parameters:\n                        raise ValueError(\n                            f\"The {parameter} parameter must be provided for all ONIOM layers specified.\"\n                        )\n                # Check that the maximum cluster number is below the number of quantum clusters for all ONIOM layers\n                if (\n                    oniom_layer_parameters[\"max_cluster_num\"]\n                    &gt; len(self.quantum_cluster_indices_set)\n                    or oniom_layer_parameters[\"max_cluster_num\"] &lt; 1\n                ):\n                    raise ValueError(\n                        \"The maximum cluster number for all ONIOM layers must be bigger than 0 and less than or equal to the number of quantum clusters generated by autoSKZCAM.\"\n                    )\n                if oniom_layer_parameters[\"max_cluster_num\"] &gt; max_cluster:\n                    max_cluster = oniom_layer_parameters[\"max_cluster_num\"]\n\n                # Check that the frozencore is either 'valence' or 'semicore'\n                if oniom_layer_parameters[\"frozen_core\"] not in [\n                    \"valence\",\n                    \"semicore\",\n                ]:\n                    raise ValueError(\n                        \"The frozen_core must be specified as either 'valence' or 'semicore'.\"\n                    )\n\n                # Check that the code is either 'mrcc' or 'orca'\n                if oniom_layer_parameters[\"code\"] not in [\"mrcc\", \"orca\"]:\n                    raise ValueError(\n                        \"The code must be specified as either 'mrcc' or 'orca'.\"\n                    )\n\n                # Ensure that basis is specified as either DZ, TZ, QZ, 5Z or CBS(X/Y)\n                if oniom_layer_parameters[\"basis\"] not in [\n                    \"DZ\",\n                    \"TZ\",\n                    \"QZ\",\n                    \"5Z\",\n                    \"CBS(DZ//TZ)\",\n                    \"CBS(TZ//QZ)\",\n                    \"CBS(QZ//5Z)\",\n                ]:\n                    raise ValueError(\n                        \"The basis must be specified as either DZ, TZ, QZ, 5Z, CBS(DZ//TZ), CBS(TZ//QZ) or CBS(QZ//5Z).\"\n                    )\n\n                # Some checks of the element_info in the case where the layer involves a CBS calculation\n                # If element_info is provided, check that it is a dictionary\n                if (\n                    \"element_info\" in oniom_layer_parameters\n                    and oniom_layer_parameters[\"element_info\"] is not None\n                ):\n                    # Check that the keys in element_info are valid element symbols\n                    if not all(\n                        key in frozen_core_defaults[\"semicore\"]\n                        for key in oniom_layer_parameters[\"element_info\"]\n                    ):\n                        raise ValueError(\n                            \"The keys in the element_info dictionary must be valid element symbols.\"\n                        )\n                    # If the basis set is a CBS basis set, ensure that the basis set is split into two\n                    if is_valid_cbs_format(oniom_layer_parameters[\"basis\"])[0]:\n                        for element in oniom_layer_parameters[\"element_info\"]:\n                            for basis_type in [\n                                \"basis\",\n                                \"ri_scf_basis\",\n                                \"ri_cwft_basis\",\n                            ]:\n                                if (\n                                    basis_type\n                                    in oniom_layer_parameters[\"element_info\"][\n                                        element\n                                    ]\n                                    and not is_valid_cbs_format(\n                                        oniom_layer_parameters[\"element_info\"][\n                                            element\n                                        ][basis_type]\n                                    )[0]\n                                ):\n                                    raise ValueError(\n                                        f\"The {basis_type} parameter must be provided in the element_info dictionary as format CBS(X//Y), where X and Y are the two basis sets.\"\n                                    )\n\n                # If code_inputs is provided and the code is orca, check that the orcasimpleinput and orcablocks are provided\n                if (\n                    oniom_layer_parameters[\"code\"] == \"orca\"\n                    and \"code_inputs\" in oniom_layer_parameters\n                    and oniom_layer_parameters[\"code_inputs\"] is not None\n                ):\n                    for key in oniom_layer_parameters[\"code_inputs\"]:\n                        if key not in [\"orcasimpleinput\", \"orcablocks\"]:\n                            raise ValueError(\n                                \"If the code is orca, the code_inputs dictionary can only contain the orcasimpleinput and orcablocks keys.\"\n                            )\n\n        if \"bulk\" in layer_name.lower():\n            if (\n                OniomInfo[layer_name][\"hl\"] is None\n                or OniomInfo[layer_name][\"ll\"] is not None\n            ):\n                raise ValueError(\n                    f\"For the {layer_name} layer, only high-level portion should be supplied.\"\n                )\n        elif \"fse\" in layer_name.lower():\n            # Ensure both hl and ll are provided\n            if (\n                OniomInfo[layer_name][\"hl\"] is None\n                or OniomInfo[layer_name][\"ll\"] is None\n            ):\n                raise ValueError(\n                    f\"For the {layer_name} layer, both high-level and low-level portions should be supplied.\"\n                )\n            # Ensure that the only parameter which is different is the max_cluster_num\n            if not all(\n                [\n                    OniomInfo[layer_name][\"hl\"][key]\n                    == OniomInfo[layer_name][\"ll\"][key]\n                    for key in OniomInfo[layer_name][\"hl\"]\n                    if key != \"max_cluster_num\"\n                ]\n                + [\n                    OniomInfo[layer_name][\"hl\"][\"max_cluster_num\"]\n                    &gt; OniomInfo[layer_name][\"ll\"][\"max_cluster_num\"]\n                ]\n            ):\n                raise ValueError(\n                    f\"The only parameter which should be different between the high-level and low-level calculations is the max_cluster_num, which should be the high-level for the {layer_name} layer.\"\n                )\n        elif \"delta\" in layer_name.lower():\n            # Ensure both hl and ll are provided\n            if (\n                OniomInfo[layer_name][\"hl\"] is None\n                or OniomInfo[layer_name][\"ll\"] is None\n            ):\n                raise ValueError(\n                    f\"Both high-level and low-level portions should be supplied for the {layer_name} layer.\"\n                )\n            # Ensure that max_cluster_num is the same for both hl and ll\n            if (\n                OniomInfo[layer_name][\"hl\"][\"max_cluster_num\"]\n                != OniomInfo[layer_name][\"ll\"][\"max_cluster_num\"]\n            ):\n                raise ValueError(\n                    f\"The {layer_name} layer should have max_cluster_num that is same for both the high-level and low-level calculations.\"\n                )\n        else:\n            raise ValueError(\n                f\"The {layer_name} layer should contain the keywords: 'bulk', 'fse' or 'delta'.\"\n            )\n    self.max_cluster = max_cluster\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.EmbeddedCluster","title":"EmbeddedCluster  <code>instance-attribute</code>","text":"<pre><code>EmbeddedCluster = EmbeddedCluster\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.OniomInfo","title":"OniomInfo  <code>instance-attribute</code>","text":"<pre><code>OniomInfo = OniomInfo\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.adsorbate_slab_embedded_cluster","title":"adsorbate_slab_embedded_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_embedded_cluster = adsorbate_slab_embedded_cluster\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.capped_ecp","title":"capped_ecp  <code>instance-attribute</code>","text":"<pre><code>capped_ecp = formatted_capped_ecp\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.ecp_region_indices_set","title":"ecp_region_indices_set  <code>instance-attribute</code>","text":"<pre><code>ecp_region_indices_set = ecp_region_indices_set\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.max_cluster","title":"max_cluster  <code>instance-attribute</code>","text":"<pre><code>max_cluster = max_cluster\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.multiplicities","title":"multiplicities  <code>instance-attribute</code>","text":"<pre><code>multiplicities = multiplicities\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.quantum_cluster_indices_set","title":"quantum_cluster_indices_set  <code>instance-attribute</code>","text":"<pre><code>quantum_cluster_indices_set = quantum_cluster_indices_set\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.create_cluster_calcs","title":"create_cluster_calcs","text":"<pre><code>create_cluster_calcs() -&gt; None\n</code></pre> <p>Create the set of calculations needed to be performed for each cluster from the series of clusters generated by the autoSKZCAM.embed.CreateEmbeddedCluster class.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/oniom.py</code> <pre><code>def create_cluster_calcs(self) -&gt; None:\n    \"\"\"\n    Create the set of calculations needed to be performed for each cluster from the series of clusters generated by the [autoSKZCAM.embed.CreateEmbeddedCluster][] class.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    # Set up the dictionary to store the information for each cluster\n    skzcam_cluster_calculators: dict[int, dict[str, CalculatorInfo]] = {\n        cluster_num: {} for cluster_num in range(1, self.max_cluster + 1)\n    }\n    for oniom_layer in self.OniomInfo.values():\n        for level in [\"ll\", \"hl\"]:\n            if oniom_layer[level] is not None:\n                oniom_layer_parameters = oniom_layer[level]\n                frozen_core = oniom_layer_parameters[\"frozen_core\"]\n                method = oniom_layer_parameters[\"method\"].replace(\" \", \"_\")\n                code = oniom_layer_parameters[\"code\"].lower()\n\n                # Continue if the code is MRCC and the method is (L)MP2 for the low-level and (LNO-)CCSD(T) for the high-level\n                if (\n                    code == \"mrcc\"\n                    and level == \"ll\"\n                    and \"MP2\" in oniom_layer[\"ll\"][\"method\"].upper()\n                    and \"CCSD(T)\" in oniom_layer[\"hl\"][\"method\"].upper()\n                ):\n                    continue\n\n                # Continue if the code is ORCA and the method is MP2 for the low-level and CCSD(T) for the high-level\n                if (\n                    code == \"orca\"\n                    and level == \"ll\"\n                    and oniom_layer[\"ll\"][\"method\"].upper() == \"MP2\"\n                    and oniom_layer[\"hl\"][\"method\"].upper() == \"CCSD(T)\"\n                ):\n                    continue\n\n                (is_cbs, basis_1, basis_2) = is_valid_cbs_format(\n                    oniom_layer_parameters[\"basis\"]\n                )\n                if is_cbs:\n                    basis_sets = [basis_1, basis_2]\n                else:\n                    basis_sets = [oniom_layer_parameters[\"basis\"]]\n                for basis_idx, basis_set in enumerate(basis_sets):\n                    default_element_info = self.create_element_info(\n                        frozen_core=frozen_core, basis=basis_set, code=code\n                    )\n                    if (\n                        \"element_info\" in oniom_layer_parameters\n                        and oniom_layer_parameters[\"element_info\"] is not None\n                    ):\n                        custom_element_info = {}\n                        for key, value in oniom_layer_parameters[\n                            \"element_info\"\n                        ].items():\n                            custom_element_info[key] = {}\n                            for subkey, subvalue in value.items():\n                                if \"basis\" in subkey:\n                                    is_element_basis_cbs = is_valid_cbs_format(\n                                        subvalue\n                                    )\n                                    if is_cbs and is_element_basis_cbs[0]:\n                                        custom_element_info[key][subkey] = (\n                                            is_element_basis_cbs[basis_idx + 1]\n                                        )\n                                    else:\n                                        custom_element_info[key][subkey] = subvalue\n                                else:\n                                    custom_element_info[key][subkey] = subvalue\n\n                        element_info = {\n                            **default_element_info,\n                            **custom_element_info,\n                        }\n                    else:\n                        element_info = default_element_info\n\n                    calculation_label = f\"{code} {method} {frozen_core} {basis_set}\"\n                    for (\n                        cluster_num,\n                        cluster_calculators,\n                    ) in skzcam_cluster_calculators.items():\n                        if (\n                            calculation_label not in cluster_calculators\n                            and cluster_num\n                            &lt; oniom_layer_parameters[\"max_cluster_num\"] + 1\n                        ):\n                            skzcam_cluster_calculators[cluster_num][\n                                calculation_label\n                            ] = self.initialise_calculator(\n                                oniom_layer_parameters=oniom_layer_parameters,\n                                quantum_cluster_indices=self.quantum_cluster_indices_set[\n                                    cluster_num - 1\n                                ],\n                                ecp_region_indices=self.ecp_region_indices_set[\n                                    cluster_num - 1\n                                ],\n                                element_info=element_info,\n                            )\n\n    self.EmbeddedCluster.skzcam_calcs = skzcam_cluster_calculators\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.create_element_info","title":"create_element_info","text":"<pre><code>create_element_info(frozen_core: Literal['valence', 'semicore'], basis: Literal['DZ', 'TZ', 'QZ', '5Z'], code: Literal['mrcc', 'orca'], ecp: dict[ElementStr, str] | None = None) -&gt; dict[ElementStr, ElementInfo]\n</code></pre> <p>Creates the element info dictionary for the SKZCAM input across each oniom layer.</p> <p>Parameters:</p> <ul> <li> <code>frozen_core</code>               (<code>Literal['valence', 'semicore']</code>)           \u2013            <p>The frozen core to use for the quantum cluster. This could be specified as a string being either 'semicore' or 'valence'.</p> </li> <li> <code>basis</code>               (<code>Literal['DZ', 'TZ', 'QZ', '5Z']</code>)           \u2013            <p>The basis set to use for the quantum cluster. This could be either double-zeta, triple-zeta, quadruple-zeta, quintuple-zeta, denoted as 'DZ', 'TZ',' QZ' and '5Z' respectively.</p> </li> <li> <code>code</code>               (<code>Literal['mrcc', 'orca']</code>)           \u2013            <p>The code to use for the quantum cluster. This could be either mrcc or orca.</p> </li> <li> <code>ecp</code>               (<code>dict[ElementStr, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>The effective core potential to use for each element within the quantum cluster.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[ElementStr, ElementInfo]</code>           \u2013            <p>A dictionary with elements as keys which gives the (1) number of core electrons as <code>core</code>, (2) basis set as <code>basis</code>, (3) effective core potential as <code>ecp</code>, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as <code>ri_scf_basis</code> and (5) resolution-of-identity/density-fitting for correlated wave-function methods as <code>ri_cwft_basis</code>.</p> </li> </ul> Source code in <code>autoSKZCAM/oniom.py</code> <pre><code>def create_element_info(\n    self,\n    frozen_core: Literal[\"valence\", \"semicore\"],\n    basis: Literal[\"DZ\", \"TZ\", \"QZ\", \"5Z\"],\n    code: Literal[\"mrcc\", \"orca\"],\n    ecp: dict[ElementStr, str] | None = None,\n) -&gt; dict[ElementStr, ElementInfo]:\n    \"\"\"\n    Creates the element info dictionary for the SKZCAM input across each oniom layer.\n\n    Parameters\n    ----------\n    frozen_core\n        The frozen core to use for the quantum cluster. This could be specified as a string being either 'semicore' or 'valence'.\n    basis\n        The basis set to use for the quantum cluster. This could be either double-zeta, triple-zeta, quadruple-zeta, quintuple-zeta, denoted as 'DZ', 'TZ',' QZ' and '5Z' respectively.\n    code\n        The code to use for the quantum cluster. This could be either mrcc or orca.\n    ecp\n        The effective core potential to use for each element within the quantum cluster.\n\n    Returns\n    -------\n    dict[ElementStr, ElementInfo]\n        A dictionary with elements as keys which gives the (1) number of core electrons as `core`, (2) basis set as `basis`, (3) effective core potential as `ecp`, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as `ri_scf_basis` and (5) resolution-of-identity/density-fitting for correlated wave-function methods as `ri_cwft_basis`.\n    \"\"\"\n\n    # Create an adsorbate_slab_quantum_cluster object for the first SKZCAM cluster\n    adsorbate_slab_quantum_cluster = self.adsorbate_slab_embedded_cluster[\n        self.quantum_cluster_indices_set[0]\n    ]\n\n    element_info_dict = {}\n    # If use_presets is True, use some preset inputs based on basis set and frozen core\n    for atom_idx, atom in enumerate(adsorbate_slab_quantum_cluster):\n        if atom.symbol in element_info_dict:\n            continue\n        if adsorbate_slab_quantum_cluster.get_array(\"atom_type\")[atom_idx] in [\n            \"adsorbate\",\n            \"anion\",\n        ]:\n            element_info_dict[atom.symbol] = {\n                \"core\": frozen_core_defaults[\"valence\"][atom.symbol],\n                \"basis\": f\"aug-cc-pV{basis}\",\n                \"ecp\": None if ecp is None else ecp.get(atom.symbol, None),\n                \"ri_scf_basis\": \"def2-QZVPP-RI-JK\" if code == \"mrcc\" else \"def2/J\",\n                \"ri_cwft_basis\": f\"aug-cc-pV{basis}-RI\"\n                if code == \"mrcc\"\n                else f\"aug-cc-pV{basis}/C\",\n            }\n        elif (\n            adsorbate_slab_quantum_cluster.get_array(\"atom_type\")[atom_idx]\n            == \"cation\"\n            and frozen_core == \"valence\"\n        ):\n            element_info_dict[atom.symbol] = {\n                \"core\": frozen_core_defaults[\"valence\"][atom.symbol],\n                \"basis\": f\"cc-pV{basis}\",\n                \"ecp\": None if ecp is None else ecp.get(atom.symbol, None),\n                \"ri_scf_basis\": \"def2-QZVPP-RI-JK\" if code == \"mrcc\" else \"def2/J\",\n                \"ri_cwft_basis\": f\"cc-pV{basis}-RI\"\n                if code == \"mrcc\"\n                else f\"cc-pV{basis}/C\",\n            }\n        elif (\n            adsorbate_slab_quantum_cluster.get_array(\"atom_type\")[atom_idx]\n            == \"cation\"\n            and frozen_core == \"semicore\"\n        ):\n            element_info_dict[atom.symbol] = {\n                \"core\": frozen_core_defaults[\"semicore\"][atom.symbol],\n                \"basis\": f\"cc-pwCV{basis}\",\n                \"ecp\": None if ecp is None else ecp.get(atom.symbol, None),\n                \"ri_scf_basis\": \"def2-QZVPP-RI-JK\" if code == \"mrcc\" else \"def2/J\",\n                \"ri_cwft_basis\": f\"cc-pwCV{basis}-RI\"\n                if code == \"mrcc\"\n                else \"AutoAux\",\n            }\n\n    return element_info_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.Prepare.initialise_calculator","title":"initialise_calculator","text":"<pre><code>initialise_calculator(oniom_layer_parameters: OniomLayerInfo, quantum_cluster_indices: list[int], ecp_region_indices: list[int], element_info: dict[ElementStr, ElementInfo]) -&gt; CalculatorInfo\n</code></pre> <p>Initialize the ASE calculator for the quantum cluster with the necessary inputs.</p> <p>Parameters:</p> <ul> <li> <code>oniom_layer_parameters</code>               (<code>OniomLayerInfo</code>)           \u2013            <p>A dictionary containing the information for each of the calculations for each of the ONIOM layers. An arbitrary number of ONIOM layers can be included.</p> </li> <li> <code>quantum_cluster_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms in the quantum cluster.</p> </li> <li> <code>ecp_region_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms in the ECP region.</p> </li> <li> <code>element_info</code>               (<code>dict[ElementStr, ElementInfo]</code>)           \u2013            <p>A dictionary with elements as keys which gives the (1) number of core electrons as <code>core</code>, (2) basis set as <code>basis</code>, (3) effective core potential as <code>ecp</code>, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as <code>ri_scf_basis</code> and (5) resolution-of-identity/density-fitting for correlated wave-function methods as <code>ri_cwft_basis</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CalculatorInfo</code>           \u2013            <p>A dictionary containing the ASE Atoms object for the 'adsorbate', 'slab' and 'adsorbate_slab' structures, and the ASE calculator for each structure.</p> </li> </ul> Source code in <code>autoSKZCAM/oniom.py</code> <pre><code>def initialise_calculator(\n    self,\n    oniom_layer_parameters: OniomLayerInfo,\n    quantum_cluster_indices: list[int],\n    ecp_region_indices: list[int],\n    element_info: dict[ElementStr, ElementInfo],\n) -&gt; CalculatorInfo:\n    \"\"\"\n    Initialize the ASE calculator for the quantum cluster with the necessary inputs.\n\n    Parameters\n    ----------\n    oniom_layer_parameters\n        A dictionary containing the information for each of the calculations for each of the ONIOM layers. An arbitrary number of ONIOM layers can be included.\n    quantum_cluster_indices\n        The indices of the atoms in the quantum cluster.\n    ecp_region_indices\n        The indices of the atoms in the ECP region.\n    element_info\n        A dictionary with elements as keys which gives the (1) number of core electrons as `core`, (2) basis set as `basis`, (3) effective core potential as `ecp`, (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as `ri_scf_basis` and (5) resolution-of-identity/density-fitting for correlated wave-function methods as `ri_cwft_basis`.\n\n    Returns\n    -------\n    CalculatorInfo\n        A dictionary containing the ASE Atoms object for the 'adsorbate', 'slab' and 'adsorbate_slab' structures, and the ASE calculator for each structure.\n    \"\"\"\n    code = oniom_layer_parameters[\"code\"]\n    method = oniom_layer_parameters[\"method\"]\n\n    atom_type_list = self.adsorbate_slab_embedded_cluster.arrays[\"atom_type\"]\n    adsorbate_slab_idx = quantum_cluster_indices\n    slab_idx = [i for i in adsorbate_slab_idx if atom_type_list[i] != \"adsorbate\"]\n    adsorbate_idx = [\n        i for i in adsorbate_slab_idx if atom_type_list[i] == \"adsorbate\"\n    ]\n\n    adsorbate_slab_quantum_cluster = deepcopy(\n        self.adsorbate_slab_embedded_cluster[adsorbate_slab_idx]\n    )\n    slab_quantum_cluster = deepcopy(self.adsorbate_slab_embedded_cluster[slab_idx])\n    adsorbate_quantum_cluster = deepcopy(\n        self.adsorbate_slab_embedded_cluster[adsorbate_idx]\n    )\n\n    calculators = {\n        \"adsorbate_slab\": adsorbate_slab_quantum_cluster,\n        \"slab\": slab_quantum_cluster,\n        \"adsorbate\": adsorbate_quantum_cluster,\n    }\n\n    # Depending on the code, set the calculator and inputs\n    if code == \"mrcc\":\n        # Use MRCCInputGenerator to generate the necessary blocks for the SKZCAM protocol for the MRCC ASE calculator\n        inputgenerator = MRCCInputGenerator(\n            adsorbate_slab_embedded_cluster=self.adsorbate_slab_embedded_cluster,\n            quantum_cluster_indices=quantum_cluster_indices,\n            ecp_region_indices=ecp_region_indices,\n            element_info=element_info,\n            include_cp=True,\n            multiplicities=self.multiplicities,\n        )\n\n        mrcc_skzcam_inputs = inputgenerator.generate_input()\n        genbas_file = inputgenerator.create_genbas_file().replace(\n            \"INSERT_cappedECP\", self.capped_ecp[\"mrcc\"]\n        )\n\n        if method.upper() == \"LNO-CCSD(T)\":\n            mrcc_default_method_inputs = code_calculation_defaults[code][\n                \"LNO-CCSD(T)\"\n            ]\n        elif method.upper() in [\"MP2\", \"RI-MP2\"]:\n            mrcc_default_method_inputs = code_calculation_defaults[code][\"MP2\"]\n        elif method.upper() == \"LMP2\":\n            mrcc_default_method_inputs = code_calculation_defaults[code][\"LMP2\"]\n        elif method.upper() == \"CCSD(T)\":\n            mrcc_default_method_inputs = code_calculation_defaults[code][\"CCSD(T)\"]\n        else:\n            mrcc_default_method_inputs = code_calculation_defaults[code][\"Other\"]\n\n        # Add default values to the mrcc_calc_inputs dictionary\n        if (\n            \"code_inputs\" in oniom_layer_parameters\n            and oniom_layer_parameters[\"code_inputs\"] is not None\n        ):\n            mrcc_calc_inputs = {\n                **mrcc_default_method_inputs,\n                **oniom_layer_parameters[\"code_inputs\"],\n            }\n        else:\n            mrcc_calc_inputs = {**mrcc_default_method_inputs}\n\n        # Combine with the mrcc_block inputs\n        inputs = {\n            structure: {**mrcc_calc_inputs, **mrcc_skzcam_inputs[structure]}\n            for structure in mrcc_skzcam_inputs\n        }\n\n        # Add \"genbas\" to the inputs dictionary\n        inputs[\"adsorbate_slab\"][\"genbas\"] = genbas_file\n        inputs[\"slab\"][\"genbas\"] = genbas_file\n        inputs[\"adsorbate\"][\"genbas\"] = genbas_file\n\n        for structure, calculator in calculators.items():\n            calculator.calc = MRCC(\n                profile=MrccProfile(command=get_settings().MRCC_CMD),\n                **inputs[structure],\n            )\n\n    elif code == \"orca\":\n        # Use ORCAInputGenerator to generate the necessary orca_blocks for the ORCA ASE calculator\n        inputgenerator = ORCAInputGenerator(\n            adsorbate_slab_embedded_cluster=self.adsorbate_slab_embedded_cluster,\n            quantum_cluster_indices=quantum_cluster_indices,\n            ecp_region_indices=ecp_region_indices,\n            element_info=element_info,\n            include_cp=True,\n            multiplicities=self.multiplicities,\n        )\n\n        orca_skzcam_inputs = inputgenerator.generate_input()\n        pc_file = inputgenerator.create_point_charge_file()\n\n        if method.upper() == \"DLPNO-CCSD(T)\":\n            orcasimpleinput = code_calculation_defaults[code][\"orcasimpleinput\"][\n                \"DLPNO-CCSD(T)\"\n            ]\n        elif method.upper() == \"DLPNO-MP2\":\n            orcasimpleinput = code_calculation_defaults[code][\"orcasimpleinput\"][\n                \"DLPNO-MP2\"\n            ]\n        elif method.upper() in [\"MP2\", \"RI-MP2\"]:\n            orcasimpleinput = code_calculation_defaults[code][\"orcasimpleinput\"][\n                \"MP2\"\n            ]\n        elif method.upper() == \"CCSD(T)\":\n            orcasimpleinput = code_calculation_defaults[code][\"orcasimpleinput\"][\n                \"CCSD(T)\"\n            ]\n        else:\n            orcasimpleinput = code_calculation_defaults[code][\"orcasimpleinput\"][\n                \"Other\"\n            ]\n\n        orcablocks = code_calculation_defaults[code][\"orcablocks\"]\n\n        if (\n            \"code_inputs\" in oniom_layer_parameters\n            and oniom_layer_parameters[\"code_inputs\"] is not None\n        ):\n            if \"orcasimpleinput\" in oniom_layer_parameters[\"code_inputs\"]:\n                orcasimpleinput = oniom_layer_parameters[\"code_inputs\"][\n                    \"orcasimpleinput\"\n                ]\n            if \"orcablocks\" in oniom_layer_parameters[\"code_inputs\"]:\n                orcablocks = oniom_layer_parameters[\"code_inputs\"][\"orcablocks\"]\n\n        # Add simpleinput and blocks to the orca_inputs dictionary\n        inputs = {\n            structure: {\n                \"orcasimpleinput\": orcasimpleinput,\n                \"orcablocks\": f\"{orcablocks}\\n{orca_skzcam_inputs[structure].replace('cappedECP', self.capped_ecp['orca'])}\",\n            }\n            for structure in orca_skzcam_inputs\n        }\n\n        # Add \"pointcharges\" to the inputs dictionary\n        inputs[\"adsorbate_slab\"][\"pointcharges\"] = pc_file\n        inputs[\"slab\"][\"pointcharges\"] = pc_file\n        inputs[\"adsorbate\"][\"pointcharges\"] = None\n\n        for structure, calculator in calculators.items():\n            calculator.calc = ORCA(\n                profile=OrcaProfile(command=get_settings().ORCA_CMD),\n                **inputs[structure],\n            )\n\n    return calculators\n</code></pre>"},{"location":"reference/autoSKZCAM/oniom.html#autoSKZCAM.oniom.is_valid_cbs_format","title":"is_valid_cbs_format","text":"<pre><code>is_valid_cbs_format(string) -&gt; list[bool, str | None, str | None]\n</code></pre> <p>Returns True if the string is in the format of a CBS extrapolation when specified in element_info.</p> <p>Parameters:</p> <ul> <li> <code>string</code>           \u2013            <p>The string to be checked.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the string is in the format of a CBS extrapolation, False otherwise.</p> </li> </ul> Source code in <code>autoSKZCAM/oniom.py</code> <pre><code>def is_valid_cbs_format(string) -&gt; list[bool, str | None, str | None]:\n    \"\"\"\n    Returns True if the string is in the format of a CBS extrapolation when specified in element_info.\n\n    Parameters\n    ----------\n    string\n        The string to be checked.\n\n    Returns\n    -------\n    bool\n        True if the string is in the format of a CBS extrapolation, False otherwise.\n    \"\"\"\n    string = string.replace(\" \", \"\")\n    # Define the regex pattern with capturing groups for the strings in between\n    pattern = r\"^CBS\\((.+?)//(.+?)\\)$\"\n    # Match the string against the pattern\n    match = re.match(pattern, string)\n    if match:\n        # Return the captured groups as a tuple\n        return True, match.group(1), match.group(2)\n    return False, None, None\n</code></pre>"},{"location":"reference/autoSKZCAM/quacc.html","title":"quacc","text":"<p>Core recipes for MRCC and ORCA taken from quacc.</p>"},{"location":"reference/autoSKZCAM/quacc.html#autoSKZCAM.quacc.static_job_mrcc","title":"static_job_mrcc","text":"<pre><code>static_job_mrcc(atoms: Atoms, copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, **calc_kwargs) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Mrcc calculator. Set a value to <code>quacc.Remove</code> to remove a pre-existing key entirely.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.ase.Summarize</p> </li> </ul> Source code in <code>autoSKZCAM/quacc.py</code> <pre><code>@job\ndef static_job_mrcc(\n    atoms: Atoms,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    **calc_kwargs,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    **calc_kwargs\n        Custom kwargs for the Mrcc calculator. Set a value to\n        `quacc.Remove` to remove a pre-existing key entirely.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results from [quacc.schemas.ase.Summarize](https://quantum-accelerators.github.io/quacc/reference/quacc/schemas/ase.html)\n    \"\"\"\n\n    # Convert a charge string to an integer\n    settings = get_settings()\n\n    calc = MRCC(profile=MrccProfile(command=settings.MRCC_CMD), **calc_kwargs)\n\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(additional_fields={\"name\": \"MRCC Static\"}).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/autoSKZCAM/quacc.html#autoSKZCAM.quacc.static_job_orca","title":"static_job_orca","text":"<pre><code>static_job_orca(atoms: Atoms, orcasimpleinput: str = '', orcablocks: str = '', pointcharges: str | None = None, copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None) -&gt; RunSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>orcasimpleinput</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>List of <code>orcasimpleinput</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcasimpleinput</code>.</p> </li> <li> <code>orcablocks</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>List of <code>orcablocks</code> swaps for the calculator. To remove entries from the defaults, put a <code>#</code> in front of the name. Refer to the ase.calculators.orca.ORCA calculator for details on <code>orcablocks</code>.</p> </li> <li> <code>pointcharges</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>File containing point charges in XYZ format.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RunSchema</code>           \u2013            <p>Dictionary of results</p> </li> </ul> Source code in <code>autoSKZCAM/quacc.py</code> <pre><code>@job\ndef static_job_orca(\n    atoms: Atoms,\n    orcasimpleinput: str = \"\",\n    orcablocks: str = \"\",\n    pointcharges: str | None = None,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n) -&gt; RunSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    orcasimpleinput\n        List of `orcasimpleinput` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA](https://wiki.fysik.dtu.dk/ase/ase/calculators/orca.html) calculator for details on `orcasimpleinput`.\n    orcablocks\n        List of `orcablocks` swaps for the calculator. To remove entries\n        from the defaults, put a `#` in front of the name. Refer to the\n        [ase.calculators.orca.ORCA](https://wiki.fysik.dtu.dk/ase/ase/calculators/orca.html) calculator for details on `orcablocks`.\n    pointcharges\n        File containing point charges in XYZ format.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n\n    Returns\n    -------\n    RunSchema\n        Dictionary of results\n    \"\"\"\n\n    settings = get_settings()\n\n    calc = ORCA(\n        profile=OrcaProfile(command=settings.ORCA_CMD),\n        orcasimpleinput=orcasimpleinput,\n        orcablocks=orcablocks,\n        pointcharges=pointcharges,\n    )\n\n    final_atoms = Runner(atoms, calc, copy_files=copy_files).run_calc()\n\n    return Summarize(additional_fields={\"name\": \"ORCA Static\"}).run(final_atoms, atoms)\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes.html","title":"recipes","text":""},{"location":"reference/autoSKZCAM/recipes.html#autoSKZCAM.recipes.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['dft_ensemble_analyse', 'dft_ensemble_flow', 'get_final_autoSKZCAM_Hads', 'skzcam_analyse', 'skzcam_eint_flow', 'skzcam_initialise']\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes.html#autoSKZCAM.recipes.dft_ensemble_analyse","title":"dft_ensemble_analyse","text":"<pre><code>dft_ensemble_analyse(calc_dir: Path | str, xc_ensemble: list[str] | dict[str, str], geom_error_xc: str, vib_xc_ensemble: list[str], freeze_surface_vib: bool, temperature: float = 200.0) -&gt; dict[str, list[float]]\n</code></pre> <p>Analyses the completed DFT ensemble calculations.</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>Path or str</code>)           \u2013            <p>The directory where the calculations were performed.</p> </li> <li> <code>xc_ensemble</code>               (<code>dict[str, str]</code>)           \u2013            <p>A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.</p> </li> <li> <code>geom_error_xc</code>               (<code>str</code>)           \u2013            <p>The xc functional to be used for the geometry error calculation.</p> </li> <li> <code>vib_xc_ensemble</code>               (<code>list[str]</code>)           \u2013            <p>A list of xc functionals for which the vibrational calculations were performed.</p> </li> <li> <code>freeze_surface_vib</code>               (<code>bool</code>)           \u2013            <p>True if the vibrational calculations on the slab should be skipped.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>200.0</code> )           \u2013            <p>The temperature to get the vibrational contributions to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[float]]</code>           \u2013            <p>A dictionary containing the relaxation energy (and its geometry error) and DeltaH contributions from the DFT ensemble.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>def dft_ensemble_analyse(\n    calc_dir: Path | str,\n    xc_ensemble: list[str] | dict[str, str],\n    geom_error_xc: str,\n    vib_xc_ensemble: list[str],\n    freeze_surface_vib: bool,\n    temperature: float = 200.0,\n) -&gt; dict[str, list[float]]:\n    \"\"\"\n    Analyses the completed DFT ensemble calculations.\n\n    Parameters\n    ----------\n    calc_dir : Path or str\n        The directory where the calculations were performed.\n    xc_ensemble : dict[str, str]\n        A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.\n    geom_error_xc : str\n        The xc functional to be used for the geometry error calculation.\n    vib_xc_ensemble : list[str]\n        A list of xc functionals for which the vibrational calculations were performed.\n    freeze_surface_vib : bool\n        True if the vibrational calculations on the slab should be skipped.\n    temperature : float\n        The temperature to get the vibrational contributions to.\n\n    Returns\n    -------\n    dict[str, list[float]]\n        A dictionary containing the relaxation energy (and its geometry error) and DeltaH contributions from the DFT ensemble.\n\n    \"\"\"\n\n    # Ensure that all the functionals in vib_xc_ensemble are also in xc_ensemble\n    for vib_xc in vib_xc_ensemble:\n        if vib_xc not in xc_ensemble:\n            raise ValueError(\n                f\"The functional {vib_xc} in vib_xc_ensemble is not in the xc_ensemble.\"\n            )\n\n    # Ensure that the geom_error_xc is in the xc_ensemble\n    if geom_error_xc is not None and geom_error_xc not in xc_ensemble:\n        raise ValueError(\n            f\"The functional {geom_error_xc} in geom_error_xc is not in the xc_ensemble.\"\n        )\n\n    dft_ensemble_results = read_completed_calculations(\n        calc_dir, xc_ensemble, vib_xc_ensemble, freeze_surface_vib\n    )\n\n    # Confirm that all the calculations have been completed\n    for job_type in dft_ensemble_results:\n        for xc_func in xc_ensemble:\n            if \"vib\" in job_type and (\n                xc_func not in vib_xc_ensemble\n                or (job_type == \"07-slab_vib\" and freeze_surface_vib)\n            ):\n                continue\n            if dft_ensemble_results[job_type][xc_func] is None or (\n                \"results\" in dft_ensemble_results[job_type]\n                and \"energy\" not in dft_ensemble_results[job_type][xc_func][\"results\"]\n            ):\n                raise ValueError(\n                    f\"The {job_type} calculation for the functional {xc_func} has not been completed.\"\n                )\n\n    xc_eads_dict = dict.fromkeys(xc_ensemble, 0)\n    xc_eint_dict = dict.fromkeys(xc_ensemble, 0)\n    xc_vib_dict = dict.fromkeys(vib_xc_ensemble, 0)\n\n    for xc_func in xc_ensemble:\n        xc_eads_dict[xc_func] = (\n            dft_ensemble_results[\"04-adsorbate_slab\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"03-slab\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"01-molecule\"][xc_func][\"results\"][\"energy\"]\n        )\n        xc_eint_dict[xc_func] = (\n            dft_ensemble_results[\"08-eint_adsorbate_slab\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"09-eint_adsorbate\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"10-eint_slab\"][xc_func][\"results\"][\"energy\"]\n        )\n\n        if xc_func in vib_xc_ensemble:\n            adsorbate_slab_dU, _, _, _ = get_quasi_rrho(\n                dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func][\"results\"][\n                    \"real_vib_freqs\"\n                ],\n                dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func][\"results\"][\n                    \"imag_vib_freqs\"\n                ],\n                temperature,\n            )\n            adsorbate_dU, _, _, _ = get_quasi_rrho(\n                dft_ensemble_results[\"06-molecule_vib\"][xc_func][\"results\"][\n                    \"real_vib_freqs\"\n                ],\n                dft_ensemble_results[\"06-molecule_vib\"][xc_func][\"results\"][\n                    \"imag_vib_freqs\"\n                ],\n                temperature,\n            )\n\n            if freeze_surface_vib is False:\n                slab_dU, _, _, _ = get_quasi_rrho(\n                    dft_ensemble_results[\"07-slab_vib\"][xc_func][\"results\"][\n                        \"real_vib_freqs\"\n                    ],\n                    dft_ensemble_results[\"07-slab_vib\"][xc_func][\"results\"][\n                        \"imag_vib_freqs\"\n                    ],\n                    temperature,\n                )\n            else:\n                slab_dU = 0\n            xc_vib_dict[xc_func] = adsorbate_slab_dU - adsorbate_dU - slab_dU\n\n    erlx = xc_eads_dict[geom_error_xc] - xc_eint_dict[geom_error_xc]\n    geom_error = 2 * np.sqrt(\n        np.mean(\n            [\n                (xc_eads_dict[xc_func] - xc_eint_dict[xc_func] - erlx) ** 2\n                for xc_func in xc_ensemble\n                if xc_func != geom_error_xc\n            ]\n        )\n    )\n    return {\n        \"DFT Erlx\": [erlx * 1000, geom_error * 1000],\n        \"DFT DeltaH\": [\n            np.mean([xc_vib_dict[xc_func] for xc_func in vib_xc_ensemble]),\n            2 * np.std([xc_vib_dict[xc_func] for xc_func in vib_xc_ensemble]),\n        ],\n    }\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes.html#autoSKZCAM.recipes.dft_ensemble_flow","title":"dft_ensemble_flow","text":"<pre><code>dft_ensemble_flow(xc_ensemble: dict[str, dict[str, Any]], vib_xc_ensemble: list[str] | None = None, geom_error_xc: str | None = None, freeze_surface_vib: bool = True, job_params: dict[str, dict[str, Any]] | None = None, adsorbate: Atoms | None = None, unit_cell: Atoms | None = None, calc_dir: str | Path = './dft_calc_dir', slab_gen_func: Callable[[Atoms], Atoms] | None = None, adsorbate_slab_gen_func: Callable[[Atoms], Atoms] | None = None)\n</code></pre> <p>Workflow to perform the DFT ensemble calculations to obtain the geometry error and get the DeltaH contribution. The workflow consists of the following steps:</p> <ol> <li> <p>Relax the gas-phase molecule for each functional in the ensemble.</p> </li> <li> <p>Relax the unit cell for each functional in the ensemble.</p> </li> <li> <p>Generate and relax the slab from the relaxed solid for each functional in the ensemble.</p> </li> <li> <p>Generate and relax the adsorbate-slab complex from the relaxed adsorbate and slab for each functional in the ensemble.</p> </li> <li> <p>Perform the vibrational calculation for each functional in the ensemble.</p> </li> <li> <p>Perform the eint calculation on the chosen functional for each functional in the ensemble.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>xc_ensemble</code>               (<code>dict[str, dict[str, Any]]</code>)           \u2013            <p>A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary containing the job parameters to be used for each functional in the ensemble. If not provided, the default job parameters will be used.</p> </li> <li> <code>adsorbate</code>               (<code>Atoms</code>, default:                   <code>None</code> )           \u2013            <p>The adsorbate molecule to be used for the calculations. If not provided, will attempt to read in the adsorbate from the calc_dir.</p> </li> <li> <code>unit_cell</code>               (<code>Atoms</code>, default:                   <code>None</code> )           \u2013            <p>The unit cell of the solid to be used for the calculations. If not provided, will attempt to read in the unit cell from the calc_dir.</p> </li> <li> <code>calc_dir</code>               (<code>str or Path</code>, default:                   <code>'./dft_calc_dir'</code> )           \u2013            <p>The directory where the calculations will be performed. Defaults to './calc_dir'.</p> </li> <li> <code>slab_gen_func</code>               (<code>Callable[[Atoms], Atoms]</code>, default:                   <code>None</code> )           \u2013            <p>The function to generate the slab from the unit cell.</p> </li> <li> <code>adsorbate_slab_gen_func</code>               (<code>Callable[[Atoms], Atoms]</code>, default:                   <code>None</code> )           \u2013            <p>The function to generate the adsorbate molecule. It is important that the indices of the adsorbates are always the first indices in the Atoms object, followed by the slab Atoms object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, dic[str, VaspSchema]]</code>           \u2013            <p>A dictionary containing the results of the DFT ensemble calculations for each functional in the ensemble.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>@flow\ndef dft_ensemble_flow(\n    xc_ensemble: dict[str, dict[str, Any]],\n    vib_xc_ensemble: list[str] | None = None,\n    geom_error_xc: str | None = None,\n    freeze_surface_vib: bool = True,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    adsorbate: Atoms | None = None,\n    unit_cell: Atoms | None = None,\n    calc_dir: str | Path = \"./dft_calc_dir\",\n    slab_gen_func: Callable[[Atoms], Atoms] | None = None,\n    adsorbate_slab_gen_func: Callable[[Atoms], Atoms] | None = None,\n):\n    \"\"\"\n    Workflow to perform the DFT ensemble calculations to obtain the geometry error and get the DeltaH contribution.\n    The workflow consists of the following steps:\n\n    1. Relax the gas-phase molecule for each functional in the ensemble.\n\n    2. Relax the unit cell for each functional in the ensemble.\n\n    3. Generate and relax the slab from the relaxed solid for each functional in the ensemble.\n\n    4. Generate and relax the adsorbate-slab complex from the relaxed adsorbate and slab for each functional in the ensemble.\n\n    5. Perform the vibrational calculation for each functional in the ensemble.\n\n    6. Perform the eint calculation on the chosen functional for each functional in the ensemble.\n\n    Parameters\n    ----------\n    xc_ensemble : dict[str, dict[str, Any]]\n        A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.\n    job_params : dict[str, dict[str, Any]], optional\n        A dictionary containing the job parameters to be used for each functional in the ensemble. If not provided, the default job parameters will be used.\n    adsorbate : Atoms, optional\n        The adsorbate molecule to be used for the calculations. If not provided, will attempt to read in the adsorbate from the calc_dir.\n    unit_cell : Atoms, optional\n        The unit cell of the solid to be used for the calculations. If not provided, will attempt to read in the unit cell from the calc_dir.\n    calc_dir : str or Path, optional\n        The directory where the calculations will be performed. Defaults to './calc_dir'.\n    slab_gen_func : Callable[[Atoms], Atoms]\n        The function to generate the slab from the unit cell.\n    adsorbate_slab_gen_func : Callable[[Atoms], Atoms]\n        The function to generate the adsorbate molecule. It is important that the indices of the adsorbates are always the first indices in the Atoms object, followed by the slab Atoms object.\n\n    Returns\n    -------\n    dict[str, dic[str,VaspSchema]]\n        A dictionary containing the results of the DFT ensemble calculations for each functional in the ensemble.\n\n    \"\"\"\n\n    if vib_xc_ensemble is None:\n        vib_xc_ensemble = []\n\n    job_list = [\n        \"01-molecule\",\n        \"02-unit_cell\",\n        \"03-slab\",\n        \"04-adsorbate_slab\",\n        \"05-adsorbate_slab_vib\",\n        \"06-molecule_vib\",\n        \"07-slab_vib\",\n        \"08-eint_adsorbate_slab\",\n        \"09-eint_adsorbate\",\n        \"10-eint_slab\",\n    ]\n\n    # Ensure that all the functionals in vib_xc_ensemble are also in xc_ensemble\n    for vib_xc in vib_xc_ensemble:\n        if vib_xc not in xc_ensemble:\n            raise ValueError(\n                f\"The functional {vib_xc} in vib_xc_ensemble is not in the xc_ensemble.\"\n            )\n\n    # Ensure that the geom_error_xc is in the xc_ensemble\n    if geom_error_xc is not None and geom_error_xc not in xc_ensemble:\n        raise ValueError(\n            f\"The functional {geom_error_xc} in geom_error_xc is not in the xc_ensemble.\"\n        )\n\n    if job_params is not None:\n        for job_type in job_params:\n            if job_type not in job_list:\n                raise ValueError(\n                    f\"The {job_type} key in job_params is not valid. Please choose from the following: '01-molecule', '02-unit_cell', '03-slab', '04-adsorbate_slab', '05-adsorbate_slab_vib', '06-molecule_vib', '07-slab_vib', '08-eint_adsorbate_slab', '09-eint_adsorbate', '10-eint_slab'.\"\n                )\n    else:\n        job_params = {}\n\n    # Try to read in completed calculations from the calc_dir\n    dft_ensemble_results = read_completed_calculations(\n        calc_dir, xc_ensemble, vib_xc_ensemble, freeze_surface_vib\n    )\n\n    for xc_func, xc_func_kwargs in xc_ensemble.items():\n        # relax molecule\n        if dft_ensemble_results[\"01-molecule\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"01-molecule\", {}), **xc_func_kwargs}\n            dft_ensemble_results[\"01-molecule\"][xc_func] = relax_job(\n                adsorbate,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"01-molecule\", xc_func)\n                },\n                pmg_kpts={\"kppvol\": 1},\n                **calc_kwargs,\n            )\n\n        # relax solid\n        if dft_ensemble_results[\"02-unit_cell\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"02-unit_cell\", {}), **xc_func_kwargs}\n            relax_job1 = relax_job(\n                unit_cell,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"02-unit_cell\", xc_func)\n                },\n                relax_cell=True,\n                unique_dir=True,\n                **calc_kwargs,\n            )\n            dft_ensemble_results[\"02-unit_cell\"][xc_func] = relax_job(\n                relax_job1[\"atoms\"],\n                relax_cell=True,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"02-unit_cell\", xc_func),\n                    \"relax1\": relax_job1,\n                },\n                **calc_kwargs,\n            )\n\n        # bulk to slab\n        if dft_ensemble_results[\"03-slab\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"03-slab\", {}), **xc_func_kwargs}\n            initial_slab = slab_gen_func(\n                dft_ensemble_results[\"02-unit_cell\"][xc_func][\"atoms\"]\n            )\n            dft_ensemble_results[\"03-slab\"][xc_func] = relax_job(\n                initial_slab,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"03-slab\", xc_func)\n                },\n                pmg_kpts={\"length_densities\": [50, 50, 1]},\n                **calc_kwargs,\n            )\n\n        # slab to ads_slab\n        if dft_ensemble_results[\"04-adsorbate_slab\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"04-adsorbate_slab\", {}), **xc_func_kwargs}\n            initial_adsorbate_slab = adsorbate_slab_gen_func(\n                dft_ensemble_results[\"01-molecule\"][xc_func][\"atoms\"],\n                dft_ensemble_results[\"03-slab\"][xc_func][\"atoms\"],\n            )\n\n            dft_ensemble_results[\"04-adsorbate_slab\"][xc_func] = relax_job(\n                initial_adsorbate_slab,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"04-adsorbate_slab\", xc_func)\n                },\n                pmg_kpts={\"length_densities\": [50, 50, 1]},\n                **calc_kwargs,\n            )\n\n        if xc_func in vib_xc_ensemble:\n            # vibrational calculation\n            if dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"05-adsorbate_slab_vib\", {}),\n                    **xc_func_kwargs,\n                }\n                adsorbate_slab_vib_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][\n                    xc_func\n                ][\"atoms\"]\n\n                if freeze_surface_vib:\n                    adsorbate_len = len(\n                        dft_ensemble_results[\"01-molecule\"][xc_func][\"atoms\"]\n                    )\n                    slab_indices = list(range(len(adsorbate_slab_vib_atoms)))[\n                        adsorbate_len:\n                    ]\n                    adsorbate_slab_vib_atoms.set_constraint(\n                        FixAtoms(indices=slab_indices)\n                    )\n\n                dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func] = freq_job(\n                    adsorbate_slab_vib_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(\n                            calc_dir, \"05-adsorbate_slab_vib\", xc_func\n                        )\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n            if dft_ensemble_results[\"06-molecule_vib\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"06-molecule_vib\", {}),\n                    **xc_func_kwargs,\n                }\n                dft_ensemble_results[\"06-molecule_vib\"][xc_func] = freq_job(\n                    dft_ensemble_results[\"01-molecule\"][xc_func][\"atoms\"],\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"06-molecule_vib\", xc_func)\n                    },\n                    pmg_kpts={\"kppvol\": 1},\n                    **calc_kwargs,\n                )\n\n            if (\n                dft_ensemble_results[\"07-slab_vib\"][xc_func] is None\n                and freeze_surface_vib is False\n            ):\n                calc_kwargs = {**job_params.get(\"07-slab_vib\", {}), **xc_func_kwargs}\n                dft_ensemble_results[\"07-slab_vib\"][xc_func] = freq_job(\n                    dft_ensemble_results[\"03-slab\"][xc_func][\"atoms\"],\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"07-slab_vib\", xc_func)\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n    if geom_error_xc is not None:\n        adsorbate_len = len(dft_ensemble_results[\"01-molecule\"][geom_error_xc][\"atoms\"])\n        adsorbate_slab_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][geom_error_xc][\n            \"atoms\"\n        ]\n        fixed_adsorbate_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][\n            geom_error_xc\n        ][\"atoms\"][:adsorbate_len]\n        fixed_slab_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][geom_error_xc][\n            \"atoms\"\n        ][adsorbate_len:]\n\n        for xc_func in xc_ensemble:\n            # eint on adsorbate_slab\n            if dft_ensemble_results[\"08-eint_adsorbate_slab\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"08-eint_adsorbate_slab\", {}),\n                    **xc_func_kwargs,\n                }\n                dft_ensemble_results[\"08-eint_adsorbate_slab\"][xc_func] = static_job(\n                    adsorbate_slab_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(\n                            calc_dir, \"08-eint_adsorbate_slab\", xc_func\n                        )\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n            # eint on adsorbate\n            if dft_ensemble_results[\"09-eint_adsorbate\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"09-eint_adsorbate\", {}),\n                    **xc_func_kwargs,\n                }\n                dft_ensemble_results[\"09-eint_adsorbate\"][xc_func] = static_job(\n                    fixed_adsorbate_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"09-eint_adsorbate\", xc_func)\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n            # eint on slab\n            if dft_ensemble_results[\"10-eint_slab\"][xc_func] is None:\n                calc_kwargs = {**job_params.get(\"10-eint_slab\", {}), **xc_func_kwargs}\n                dft_ensemble_results[\"10-eint_slab\"][xc_func] = static_job(\n                    fixed_slab_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"10-eint_slab\", xc_func)\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n    return dft_ensemble_results\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes.html#autoSKZCAM.recipes.get_final_autoSKZCAM_Hads","title":"get_final_autoSKZCAM_Hads","text":"<pre><code>get_final_autoSKZCAM_Hads(skzcam_eint_analysis: dict[str, list[float]], dft_ensemble_analysis: dict[str, list[float]]) -&gt; dict[str, list[float]]\n</code></pre> <p>Gets the final Hads from the autoSKZCAM workflow after dft_ensemble and skzcam analysis.</p> <p>Parameters:</p> <ul> <li> <code>skzcam_eint_analysis</code>               (<code>dict[str, list[float]]</code>)           \u2013            <p>The dictionary of the SKZCAM Eint analysis.</p> </li> <li> <code>dft_ensemble_analysis</code>               (<code>dict[str, list[float]]</code>)           \u2013            <p>The dictionary of the DFT ensemble analysis.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[float]]</code>           \u2013            <p>The final Hads dictionary containing the Hads contributions from the DFT ensemble and the SKZCAM calculations.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes.py</code> <pre><code>def get_final_autoSKZCAM_Hads(\n    skzcam_eint_analysis: dict[str, list[float]],\n    dft_ensemble_analysis: dict[str, list[float]],\n) -&gt; dict[str, list[float]]:\n    \"\"\"\n    Gets the final Hads from the autoSKZCAM workflow after dft_ensemble and skzcam analysis.\n\n    Parameters\n    ----------\n    skzcam_eint_analysis\n        The dictionary of the SKZCAM Eint analysis.\n    dft_ensemble_analysis\n        The dictionary of the DFT ensemble analysis.\n\n    Returns\n    -------\n    dict[str, list[float]]\n        The final Hads dictionary containing the Hads contributions from the DFT ensemble and the SKZCAM calculations.\n    \"\"\"\n    final_Hads = skzcam_eint_analysis.copy()\n\n    final = skzcam_eint_analysis[\"Overall Eint\"].copy()\n    for key, contribution in dft_ensemble_analysis.items():\n        final_Hads[key] = contribution\n        final[0] += contribution[0]\n        final[1] = np.sqrt(final[1] ** 2 + contribution[1] ** 2)\n\n    final_Hads[\"Final Hads\"] = final\n    return final_Hads\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes.html#autoSKZCAM.recipes.skzcam_analyse","title":"skzcam_analyse","text":"<pre><code>skzcam_analyse(calc_dir: str | Path, embedded_cluster_npy_path: Path | str | None = None, OniomInfo: dict[str, OniomLayerInfo] | None = None, EmbeddedCluster: CreateEmbeddedCluster | None = None) -&gt; dict[str, tuple[float, float]]\n</code></pre> <p>Analyze the completed SKZCAM calculations and compute the final ONIOM contributions.</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>str | Path</code>)           \u2013            <p>The directory containing the calculations.</p> </li> <li> <code>embedded_cluster_npy_path</code>               (<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the embedded cluster .npy object.</p> </li> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster | None</code>, default:                   <code>None</code> )           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster.</p> </li> <li> <code>OniomInfo</code>               (<code>dict[str, OniomLayerInfo] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary containing the information about the ONIOM layers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, tuple[float, float]]</code>           \u2013            <p>A dictionary containing the ONIOM layer as key and a tuple containing the contribution to the final interaction energy as well as its error.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_analyse(\n    calc_dir: str | Path,\n    embedded_cluster_npy_path: Path | str | None = None,\n    OniomInfo: dict[str, OniomLayerInfo] | None = None,\n    EmbeddedCluster: CreateEmbeddedCluster | None = None,\n) -&gt; dict[str, tuple[float, float]]:\n    \"\"\"\n    Analyze the completed SKZCAM calculations and compute the final ONIOM contributions.\n\n    Parameters\n    ----------\n    calc_dir\n        The directory containing the calculations.\n    embedded_cluster_npy_path\n        The path to the embedded cluster .npy object.\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster.\n    OniomInfo\n        A dictionary containing the information about the ONIOM layers.\n\n    Returns\n    -------\n    dict[str, tuple[float, float]]\n        A dictionary containing the ONIOM layer as key and a tuple containing the contribution to the final interaction energy as well as its error.\n    \"\"\"\n\n    # Initialize the EmbeddedCluster object if it is not provided\n    if EmbeddedCluster is None and embedded_cluster_npy_path is None:\n        # Check if the embedded_cluster.npy file exists in the calc_dir\n        if not Path(calc_dir, \"embedded_cluster.npy\").exists():\n            raise ValueError(\n                \"Either the EmbeddedCluster object must be provided or embedded_cluster_npy_path is set or embedded_cluster.npy is provided in calc_dir.\"\n            )\n        EmbeddedCluster = np.load(\n            Path(calc_dir, \"embedded_cluster.npy\"), allow_pickle=True\n        ).item()\n\n    elif EmbeddedCluster is None and embedded_cluster_npy_path is not None:\n        EmbeddedCluster = np.load(embedded_cluster_npy_path, allow_pickle=True).item()\n\n    # Load the OniomInfo dictionary if it is not provided\n    if EmbeddedCluster.OniomInfo is None:\n        if OniomInfo is None:\n            raise ValueError(\n                \"The OniomInfo dictionary must be provided in EmbeddedCluster or as an argument.\"\n            )\n        EmbeddedCluster.OniomInfo = OniomInfo\n\n    if EmbeddedCluster.OniomInfo is not None and OniomInfo is None:\n        OniomInfo = EmbeddedCluster.OniomInfo\n\n    skzcam_calcs_analysis = analyze_calculations(\n        calc_dir=calc_dir,\n        embedded_cluster_path=embedded_cluster_npy_path,\n        EmbeddedCluster=EmbeddedCluster,\n    )\n\n    return compute_skzcam_int_ene(\n        skzcam_calcs_analysis=skzcam_calcs_analysis, OniomInfo=OniomInfo\n    )\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes.html#autoSKZCAM.recipes.skzcam_eint_flow","title":"skzcam_eint_flow","text":"<pre><code>skzcam_eint_flow(EmbeddedCluster: CreateEmbeddedCluster, OniomInfo: dict[str, OniomLayerInfo], capped_ecp: dict[Literal['mrcc', 'orca'], str] | None = None, **kwargs) -&gt; None\n</code></pre> <p>The complete SKZCAM protocol to generate the embedded clusters, perform the calculations, and analyze the results.</p> <p>Parameters:</p> <ul> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster</code>)           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster. This is initialised using the skzcam_initialise() function.</p> </li> <li> <code>OniomInfo</code>               (<code>dict[str, OniomLayerInfo]</code>)           \u2013            <p>A dictionary containing the information about the ONIOM layers.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the skzcam_generate_job() and skzcam_calculate_job() functions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_eint_flow(\n    EmbeddedCluster: CreateEmbeddedCluster,\n    OniomInfo: dict[str, OniomLayerInfo],\n    capped_ecp: dict[Literal[\"mrcc\", \"orca\"], str] | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The complete SKZCAM protocol to generate the embedded clusters, perform the calculations, and analyze the results.\n\n    Parameters\n    ----------\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster. This is initialised using the skzcam_initialise() function.\n    OniomInfo\n        A dictionary containing the information about the ONIOM layers.\n    **kwargs\n        Additional keyword arguments to pass to the skzcam_generate_job() and skzcam_calculate_job() functions.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # Generate the skzcam embedded clusters\n    skzcam_generate_job(EmbeddedCluster, **kwargs)\n\n    # Perform the calculations on the embedded clusters\n    skzcam_calculate_job(EmbeddedCluster, OniomInfo, capped_ecp=capped_ecp, **kwargs)\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes.html#autoSKZCAM.recipes.skzcam_initialise","title":"skzcam_initialise","text":"<pre><code>skzcam_initialise(adsorbate_indices: list[int], slab_center_indices: list[int], atom_oxi_states: dict[ElementStr, int], adsorbate_slab_file: str | Path, pun_filepath: str | Path = './ChemShell_EmbeddedCluster.pun', run_chemshell: bool = False, chemsh_radius_active: float = 40.0, chemsh_radius_cluster: float = 60.0, chemsh_bq_layer: float = 6.0, write_xyz_file: bool = False, **kwargs) -&gt; CreateEmbeddedCluster\n</code></pre> <p>Parameters to initialise the SKZCAM protocol to generate the embedded clusters.</p> <p>Parameters:</p> <ul> <li> <code>adsorbate_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms that make up the adsorbate molecule.</p> </li> <li> <code>slab_center_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.</p> </li> <li> <code>atom_oxi_states</code>               (<code>dict[ElementStr, int]</code>)           \u2013            <p>A dictionary with the element symbol as the key and its oxidation state as the value.</p> </li> <li> <code>adsorbate_slab_file</code>               (<code>str | Path</code>)           \u2013            <p>The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.</p> </li> <li> <code>pun_filepath</code>               (<code>str | Path</code>, default:                   <code>'./ChemShell_EmbeddedCluster.pun'</code> )           \u2013            <p>The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex if it has already been generated by ChemShell. If it is None, then ChemShell will need to be used to create this file.</p> </li> <li> <code>run_chemshell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the ChemShell calculations will be run to generate the .pun file.</p> </li> <li> <code>chemsh_radius_active</code>               (<code>float</code>, default:                   <code>40.0</code> )           \u2013            <p>The radius of the active region in Angstroms. This 'active' region is simply region where the charge fitting is performed to ensure correct Madelung potential; it can be a relatively large value.</p> </li> <li> <code>chemsh_radius_cluster</code>               (<code>float</code>, default:                   <code>60.0</code> )           \u2013            <p>The radius of the total embedded cluster in Angstroms.</p> </li> <li> <code>chemsh_bq_layer</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>The height above the surface to place some additional fitting point charges in Angstroms; simply for better reproduction of the electrostatic potential close to the adsorbate.</p> </li> <li> <code>write_xyz_file</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the .xyz file will be written containing the atomic coordinates of the adsorbate-slab complex.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CreateEmbeddedCluster</code>           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_initialise(\n    adsorbate_indices: list[int],\n    slab_center_indices: list[int],\n    atom_oxi_states: dict[ElementStr, int],\n    adsorbate_slab_file: str | Path,\n    pun_filepath: str | Path = \"./ChemShell_EmbeddedCluster.pun\",\n    run_chemshell: bool = False,\n    chemsh_radius_active: float = 40.0,\n    chemsh_radius_cluster: float = 60.0,\n    chemsh_bq_layer: float = 6.0,\n    write_xyz_file: bool = False,\n    **kwargs,  # noqa ARG001\n) -&gt; CreateEmbeddedCluster:\n    \"\"\"\n    Parameters to initialise the SKZCAM protocol to generate the embedded clusters.\n\n    Parameters\n    ----------\n    adsorbate_indices\n        The indices of the atoms that make up the adsorbate molecule.\n    slab_center_indices\n        The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.\n    atom_oxi_states\n        A dictionary with the element symbol as the key and its oxidation state as the value.\n    adsorbate_slab_file\n        The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.\n    pun_filepath\n        The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex if it has already been generated by ChemShell. If it is None, then ChemShell will need to be used to create this file.\n    run_chemshell\n        If True, the ChemShell calculations will be run to generate the .pun file.\n    chemsh_radius_active\n        The radius of the active region in Angstroms. This 'active' region is simply region where the charge fitting is performed to ensure correct Madelung potential; it can be a relatively large value.\n    chemsh_radius_cluster\n        The radius of the total embedded cluster in Angstroms.\n    chemsh_bq_layer\n        The height above the surface to place some additional fitting point charges in Angstroms; simply for better reproduction of the electrostatic potential close to the adsorbate.\n    write_xyz_file\n        If True, the .xyz file will be written containing the atomic coordinates of the adsorbate-slab complex.\n\n    Returns\n    -------\n    CreateEmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster.\n\n    \"\"\"\n\n    EmbeddedCluster = CreateEmbeddedCluster(\n        adsorbate_indices=adsorbate_indices,\n        slab_center_indices=slab_center_indices,\n        atom_oxi_states=atom_oxi_states,\n        adsorbate_slab_file=adsorbate_slab_file,\n        pun_filepath=pun_filepath,\n    )\n\n    # Check that pun_filepath exists if run_chemshell is False\n    if run_chemshell is False and not Path(pun_filepath).exists():\n        raise ValueError(\n            \"The path to the .pun file from ChemShell must be provided in EmbeddedCluster if run_chemshell is False.\"\n        )\n\n    if run_chemshell:\n        # Create the ChemShell input file\n        EmbeddedCluster.run_chemshell(\n            filepath=pun_filepath,\n            chemsh_radius_active=chemsh_radius_active,\n            chemsh_radius_cluster=chemsh_radius_cluster,\n            chemsh_bq_layer=chemsh_bq_layer,\n            write_xyz_file=write_xyz_file,\n        )\n\n    return EmbeddedCluster\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html","title":"recipes_dft","text":""},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.adsorbate_slab_rss_flow","title":"adsorbate_slab_rss_flow","text":"<pre><code>adsorbate_slab_rss_flow(adsorbate: Atoms, slab: Atoms, num_rss: int = 5, min_z: float = 3.0, max_z: float = 8.0, preset: str | None = 'SlabSet', copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, additional_fields: dict[str, Any] | None = None, unique_dir: bool = False, **calc_kwargs) -&gt; dict[str, VaspSchema]\n</code></pre> <p>Perform a random structure search on a specified number of structures.</p> <p>Parameters:</p> <ul> <li> <code>adsorbate</code>               (<code>Atoms</code>)           \u2013            <p>Adsorbate Atoms object</p> </li> <li> <code>slab</code>               (<code>Atoms</code>)           \u2013            <p>Slab Atoms object</p> </li> <li> <code>num_rss</code>               (<code>int</code>, default:                   <code>5</code> )           \u2013            <p>Number of random structure search calculations to perform.</p> </li> <li> <code>min_z</code>               (<code>float</code>, default:                   <code>3.0</code> )           \u2013            <p>Minimum z-height above the slab for the adsorbate.</p> </li> <li> <code>max_z</code>               (<code>float</code>, default:                   <code>8.0</code> )           \u2013            <p>Maximum z-height above the slab for the adsorbate.</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'SlabSet'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>unique_dir</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>True if a unique directory should be created for each calculation.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the quacc.calculators.vasp.vasp.Vasp calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, VaspSchema]</code>           \u2013            <p>Dictionary with RSS calculation number as key and the value is Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>@flow\ndef adsorbate_slab_rss_flow(\n    adsorbate: Atoms,\n    slab: Atoms,\n    num_rss: int = 5,\n    min_z: float = 3.0,\n    max_z: float = 8.0,\n    preset: str | None = \"SlabSet\",\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    unique_dir: bool = False,\n    **calc_kwargs,\n) -&gt; dict[str, VaspSchema]:\n    \"\"\"\n    Perform a random structure search on a specified number of structures.\n\n    Parameters\n    ----------\n    adsorbate\n        Adsorbate Atoms object\n    slab\n        Slab Atoms object\n    num_rss\n        Number of random structure search calculations to perform.\n    min_z\n        Minimum z-height above the slab for the adsorbate.\n    max_z\n        Maximum z-height above the slab for the adsorbate.\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    unique_dir\n        True if a unique directory should be created for each calculation.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [quacc.calculators.vasp.vasp.Vasp](https://quantum-accelerators.github.io/quacc/reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp) calculator.\n\n    Returns\n    -------\n    dict[str,VaspSchema]\n        Dictionary with RSS calculation number as key and the value is Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run](https://quantum-accelerators.github.io/quacc/reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize).\n        See the type-hint for the data structure.\n    \"\"\"\n\n    rng = np.random.default_rng()\n\n    calc_defaults = {\n        \"encut\": 400,\n        \"ismear\": 0,\n        \"sigma\": 0.05,\n        \"ediff\": 1e-5,\n        \"algo\": \"Fast\",\n        \"istart\": 0,\n        \"lreal\": False,\n        \"ispin\": 1,\n        \"nelm\": 200,\n        \"nelmin\": 8,\n        \"ediffg\": -0.03,\n        \"isif\": 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-8,\n    }\n\n    surface_max_z = np.max([atom.position[2] for atom in slab])\n    adsorbate_num_clashes = len(neighborlist.neighbor_list(\"i\", adsorbate, cutoff=1.4))\n    slab_num_clashes = len(neighborlist.neighbor_list(\"i\", slab, cutoff=1.4))\n    rss_results_dict = {}\n\n    rss_num = 0\n    while rss_num &lt; num_rss:\n        rotated_adsorbate = adsorbate.copy()\n        rotated_adsorbate.set_cell(slab.get_cell())\n        random_angle = rng.random() * 360.0\n        random_direction = [rng.random(), rng.random(), rng.random()]\n        rotated_adsorbate.rotate(random_angle, random_direction, center=\"COM\")\n        random_displacement = (\n            rng.random() * slab.get_cell()[0]\n            + rng.random() * slab.get_cell()[1]\n            + np.array(\n                [0.0, 0.0, surface_max_z + rng.random() * (max_z - min_z) + min_z]\n            )\n            - rotated_adsorbate.get_center_of_mass()\n        )\n        rotated_adsorbate.translate(random_displacement)\n        rss_adsorbate_slab = rotated_adsorbate + slab\n        slab_indices = slab.constraints[0].__dict__[\"index\"]\n        c = FixAtoms(indices=len(adsorbate) + slab_indices)\n        rss_adsorbate_slab.set_constraint(c)\n        num_of_clashes = len(\n            neighborlist.neighbor_list(\"i\", rss_adsorbate_slab, cutoff=1.4)\n        )\n        if num_of_clashes - adsorbate_num_clashes - slab_num_clashes == 0:\n            rss_num += 1\n            if \"calc_results_dir\" in additional_fields:\n                with change_settings(\n                    {\n                        \"RESULTS_DIR\": Path(\n                            additional_fields[\"calc_results_dir\"], f\"RSS_{rss_num:05d}\"\n                        ),\n                        \"CREATE_UNIQUE_DIR\": unique_dir,\n                        \"GZIP_FILES\": False,\n                    }\n                ):\n                    results_dict = run_and_summarize(\n                        rss_adsorbate_slab,\n                        preset=preset,\n                        calc_defaults=calc_defaults,\n                        calc_swaps=calc_kwargs,\n                        additional_fields={\n                            \"name\": f\"VASP RSS {rss_num:05d}\",\n                            \"calc_results_dir\": Path(\n                                additional_fields[\"calc_results_dir\"],\n                                \"rss_calcs\",\n                                f\"RSS_{rss_num:05d}\",\n                            ),\n                        },\n                        copy_files=copy_files,\n                    )\n            else:\n                results_dict = run_and_summarize(\n                    rss_adsorbate_slab,\n                    preset=preset,\n                    calc_defaults=calc_defaults,\n                    calc_swaps=calc_kwargs,\n                    additional_fields={\n                        \"name\": f\"VASP RSS {rss_num:05d}\",\n                        \"calc_results_dir\": Path(\n                            additional_fields[\"calc_results_dir\"],\n                            \"rss_calcs\",\n                            f\"RSS_{rss_num:05d}\",\n                        ),\n                    },\n                    copy_files=copy_files,\n                )\n            results_dict[\"atoms\"] = resort_atoms(\n                rss_adsorbate_slab, results_dict[\"atoms\"]\n            )\n            results_dict[\"atoms\"].set_constraint(rss_adsorbate_slab.constraints.copy())\n            rss_results_dict[f\"RSS_{rss_num:05d}\"] = results_dict\n    return rss_results_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.dft_ensemble_analyse","title":"dft_ensemble_analyse","text":"<pre><code>dft_ensemble_analyse(calc_dir: Path | str, xc_ensemble: list[str] | dict[str, str], geom_error_xc: str, vib_xc_ensemble: list[str], freeze_surface_vib: bool, temperature: float = 200.0) -&gt; dict[str, list[float]]\n</code></pre> <p>Analyses the completed DFT ensemble calculations.</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>Path or str</code>)           \u2013            <p>The directory where the calculations were performed.</p> </li> <li> <code>xc_ensemble</code>               (<code>dict[str, str]</code>)           \u2013            <p>A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.</p> </li> <li> <code>geom_error_xc</code>               (<code>str</code>)           \u2013            <p>The xc functional to be used for the geometry error calculation.</p> </li> <li> <code>vib_xc_ensemble</code>               (<code>list[str]</code>)           \u2013            <p>A list of xc functionals for which the vibrational calculations were performed.</p> </li> <li> <code>freeze_surface_vib</code>               (<code>bool</code>)           \u2013            <p>True if the vibrational calculations on the slab should be skipped.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>200.0</code> )           \u2013            <p>The temperature to get the vibrational contributions to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, list[float]]</code>           \u2013            <p>A dictionary containing the relaxation energy (and its geometry error) and DeltaH contributions from the DFT ensemble.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>def dft_ensemble_analyse(\n    calc_dir: Path | str,\n    xc_ensemble: list[str] | dict[str, str],\n    geom_error_xc: str,\n    vib_xc_ensemble: list[str],\n    freeze_surface_vib: bool,\n    temperature: float = 200.0,\n) -&gt; dict[str, list[float]]:\n    \"\"\"\n    Analyses the completed DFT ensemble calculations.\n\n    Parameters\n    ----------\n    calc_dir : Path or str\n        The directory where the calculations were performed.\n    xc_ensemble : dict[str, str]\n        A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.\n    geom_error_xc : str\n        The xc functional to be used for the geometry error calculation.\n    vib_xc_ensemble : list[str]\n        A list of xc functionals for which the vibrational calculations were performed.\n    freeze_surface_vib : bool\n        True if the vibrational calculations on the slab should be skipped.\n    temperature : float\n        The temperature to get the vibrational contributions to.\n\n    Returns\n    -------\n    dict[str, list[float]]\n        A dictionary containing the relaxation energy (and its geometry error) and DeltaH contributions from the DFT ensemble.\n\n    \"\"\"\n\n    # Ensure that all the functionals in vib_xc_ensemble are also in xc_ensemble\n    for vib_xc in vib_xc_ensemble:\n        if vib_xc not in xc_ensemble:\n            raise ValueError(\n                f\"The functional {vib_xc} in vib_xc_ensemble is not in the xc_ensemble.\"\n            )\n\n    # Ensure that the geom_error_xc is in the xc_ensemble\n    if geom_error_xc is not None and geom_error_xc not in xc_ensemble:\n        raise ValueError(\n            f\"The functional {geom_error_xc} in geom_error_xc is not in the xc_ensemble.\"\n        )\n\n    dft_ensemble_results = read_completed_calculations(\n        calc_dir, xc_ensemble, vib_xc_ensemble, freeze_surface_vib\n    )\n\n    # Confirm that all the calculations have been completed\n    for job_type in dft_ensemble_results:\n        for xc_func in xc_ensemble:\n            if \"vib\" in job_type and (\n                xc_func not in vib_xc_ensemble\n                or (job_type == \"07-slab_vib\" and freeze_surface_vib)\n            ):\n                continue\n            if dft_ensemble_results[job_type][xc_func] is None or (\n                \"results\" in dft_ensemble_results[job_type]\n                and \"energy\" not in dft_ensemble_results[job_type][xc_func][\"results\"]\n            ):\n                raise ValueError(\n                    f\"The {job_type} calculation for the functional {xc_func} has not been completed.\"\n                )\n\n    xc_eads_dict = dict.fromkeys(xc_ensemble, 0)\n    xc_eint_dict = dict.fromkeys(xc_ensemble, 0)\n    xc_vib_dict = dict.fromkeys(vib_xc_ensemble, 0)\n\n    for xc_func in xc_ensemble:\n        xc_eads_dict[xc_func] = (\n            dft_ensemble_results[\"04-adsorbate_slab\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"03-slab\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"01-molecule\"][xc_func][\"results\"][\"energy\"]\n        )\n        xc_eint_dict[xc_func] = (\n            dft_ensemble_results[\"08-eint_adsorbate_slab\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"09-eint_adsorbate\"][xc_func][\"results\"][\"energy\"]\n            - dft_ensemble_results[\"10-eint_slab\"][xc_func][\"results\"][\"energy\"]\n        )\n\n        if xc_func in vib_xc_ensemble:\n            adsorbate_slab_dU, _, _, _ = get_quasi_rrho(\n                dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func][\"results\"][\n                    \"real_vib_freqs\"\n                ],\n                dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func][\"results\"][\n                    \"imag_vib_freqs\"\n                ],\n                temperature,\n            )\n            adsorbate_dU, _, _, _ = get_quasi_rrho(\n                dft_ensemble_results[\"06-molecule_vib\"][xc_func][\"results\"][\n                    \"real_vib_freqs\"\n                ],\n                dft_ensemble_results[\"06-molecule_vib\"][xc_func][\"results\"][\n                    \"imag_vib_freqs\"\n                ],\n                temperature,\n            )\n\n            if freeze_surface_vib is False:\n                slab_dU, _, _, _ = get_quasi_rrho(\n                    dft_ensemble_results[\"07-slab_vib\"][xc_func][\"results\"][\n                        \"real_vib_freqs\"\n                    ],\n                    dft_ensemble_results[\"07-slab_vib\"][xc_func][\"results\"][\n                        \"imag_vib_freqs\"\n                    ],\n                    temperature,\n                )\n            else:\n                slab_dU = 0\n            xc_vib_dict[xc_func] = adsorbate_slab_dU - adsorbate_dU - slab_dU\n\n    erlx = xc_eads_dict[geom_error_xc] - xc_eint_dict[geom_error_xc]\n    geom_error = 2 * np.sqrt(\n        np.mean(\n            [\n                (xc_eads_dict[xc_func] - xc_eint_dict[xc_func] - erlx) ** 2\n                for xc_func in xc_ensemble\n                if xc_func != geom_error_xc\n            ]\n        )\n    )\n    return {\n        \"DFT Erlx\": [erlx * 1000, geom_error * 1000],\n        \"DFT DeltaH\": [\n            np.mean([xc_vib_dict[xc_func] for xc_func in vib_xc_ensemble]),\n            2 * np.std([xc_vib_dict[xc_func] for xc_func in vib_xc_ensemble]),\n        ],\n    }\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.dft_ensemble_flow","title":"dft_ensemble_flow","text":"<pre><code>dft_ensemble_flow(xc_ensemble: dict[str, dict[str, Any]], vib_xc_ensemble: list[str] | None = None, geom_error_xc: str | None = None, freeze_surface_vib: bool = True, job_params: dict[str, dict[str, Any]] | None = None, adsorbate: Atoms | None = None, unit_cell: Atoms | None = None, calc_dir: str | Path = './dft_calc_dir', slab_gen_func: Callable[[Atoms], Atoms] | None = None, adsorbate_slab_gen_func: Callable[[Atoms], Atoms] | None = None)\n</code></pre> <p>Workflow to perform the DFT ensemble calculations to obtain the geometry error and get the DeltaH contribution. The workflow consists of the following steps:</p> <ol> <li> <p>Relax the gas-phase molecule for each functional in the ensemble.</p> </li> <li> <p>Relax the unit cell for each functional in the ensemble.</p> </li> <li> <p>Generate and relax the slab from the relaxed solid for each functional in the ensemble.</p> </li> <li> <p>Generate and relax the adsorbate-slab complex from the relaxed adsorbate and slab for each functional in the ensemble.</p> </li> <li> <p>Perform the vibrational calculation for each functional in the ensemble.</p> </li> <li> <p>Perform the eint calculation on the chosen functional for each functional in the ensemble.</p> </li> </ol> <p>Parameters:</p> <ul> <li> <code>xc_ensemble</code>               (<code>dict[str, dict[str, Any]]</code>)           \u2013            <p>A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.</p> </li> <li> <code>job_params</code>               (<code>dict[str, dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary containing the job parameters to be used for each functional in the ensemble. If not provided, the default job parameters will be used.</p> </li> <li> <code>adsorbate</code>               (<code>Atoms</code>, default:                   <code>None</code> )           \u2013            <p>The adsorbate molecule to be used for the calculations. If not provided, will attempt to read in the adsorbate from the calc_dir.</p> </li> <li> <code>unit_cell</code>               (<code>Atoms</code>, default:                   <code>None</code> )           \u2013            <p>The unit cell of the solid to be used for the calculations. If not provided, will attempt to read in the unit cell from the calc_dir.</p> </li> <li> <code>calc_dir</code>               (<code>str or Path</code>, default:                   <code>'./dft_calc_dir'</code> )           \u2013            <p>The directory where the calculations will be performed. Defaults to './calc_dir'.</p> </li> <li> <code>slab_gen_func</code>               (<code>Callable[[Atoms], Atoms]</code>, default:                   <code>None</code> )           \u2013            <p>The function to generate the slab from the unit cell.</p> </li> <li> <code>adsorbate_slab_gen_func</code>               (<code>Callable[[Atoms], Atoms]</code>, default:                   <code>None</code> )           \u2013            <p>The function to generate the adsorbate molecule. It is important that the indices of the adsorbates are always the first indices in the Atoms object, followed by the slab Atoms object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, dic[str, VaspSchema]]</code>           \u2013            <p>A dictionary containing the results of the DFT ensemble calculations for each functional in the ensemble.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>@flow\ndef dft_ensemble_flow(\n    xc_ensemble: dict[str, dict[str, Any]],\n    vib_xc_ensemble: list[str] | None = None,\n    geom_error_xc: str | None = None,\n    freeze_surface_vib: bool = True,\n    job_params: dict[str, dict[str, Any]] | None = None,\n    adsorbate: Atoms | None = None,\n    unit_cell: Atoms | None = None,\n    calc_dir: str | Path = \"./dft_calc_dir\",\n    slab_gen_func: Callable[[Atoms], Atoms] | None = None,\n    adsorbate_slab_gen_func: Callable[[Atoms], Atoms] | None = None,\n):\n    \"\"\"\n    Workflow to perform the DFT ensemble calculations to obtain the geometry error and get the DeltaH contribution.\n    The workflow consists of the following steps:\n\n    1. Relax the gas-phase molecule for each functional in the ensemble.\n\n    2. Relax the unit cell for each functional in the ensemble.\n\n    3. Generate and relax the slab from the relaxed solid for each functional in the ensemble.\n\n    4. Generate and relax the adsorbate-slab complex from the relaxed adsorbate and slab for each functional in the ensemble.\n\n    5. Perform the vibrational calculation for each functional in the ensemble.\n\n    6. Perform the eint calculation on the chosen functional for each functional in the ensemble.\n\n    Parameters\n    ----------\n    xc_ensemble : dict[str, dict[str, Any]]\n        A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.\n    job_params : dict[str, dict[str, Any]], optional\n        A dictionary containing the job parameters to be used for each functional in the ensemble. If not provided, the default job parameters will be used.\n    adsorbate : Atoms, optional\n        The adsorbate molecule to be used for the calculations. If not provided, will attempt to read in the adsorbate from the calc_dir.\n    unit_cell : Atoms, optional\n        The unit cell of the solid to be used for the calculations. If not provided, will attempt to read in the unit cell from the calc_dir.\n    calc_dir : str or Path, optional\n        The directory where the calculations will be performed. Defaults to './calc_dir'.\n    slab_gen_func : Callable[[Atoms], Atoms]\n        The function to generate the slab from the unit cell.\n    adsorbate_slab_gen_func : Callable[[Atoms], Atoms]\n        The function to generate the adsorbate molecule. It is important that the indices of the adsorbates are always the first indices in the Atoms object, followed by the slab Atoms object.\n\n    Returns\n    -------\n    dict[str, dic[str,VaspSchema]]\n        A dictionary containing the results of the DFT ensemble calculations for each functional in the ensemble.\n\n    \"\"\"\n\n    if vib_xc_ensemble is None:\n        vib_xc_ensemble = []\n\n    job_list = [\n        \"01-molecule\",\n        \"02-unit_cell\",\n        \"03-slab\",\n        \"04-adsorbate_slab\",\n        \"05-adsorbate_slab_vib\",\n        \"06-molecule_vib\",\n        \"07-slab_vib\",\n        \"08-eint_adsorbate_slab\",\n        \"09-eint_adsorbate\",\n        \"10-eint_slab\",\n    ]\n\n    # Ensure that all the functionals in vib_xc_ensemble are also in xc_ensemble\n    for vib_xc in vib_xc_ensemble:\n        if vib_xc not in xc_ensemble:\n            raise ValueError(\n                f\"The functional {vib_xc} in vib_xc_ensemble is not in the xc_ensemble.\"\n            )\n\n    # Ensure that the geom_error_xc is in the xc_ensemble\n    if geom_error_xc is not None and geom_error_xc not in xc_ensemble:\n        raise ValueError(\n            f\"The functional {geom_error_xc} in geom_error_xc is not in the xc_ensemble.\"\n        )\n\n    if job_params is not None:\n        for job_type in job_params:\n            if job_type not in job_list:\n                raise ValueError(\n                    f\"The {job_type} key in job_params is not valid. Please choose from the following: '01-molecule', '02-unit_cell', '03-slab', '04-adsorbate_slab', '05-adsorbate_slab_vib', '06-molecule_vib', '07-slab_vib', '08-eint_adsorbate_slab', '09-eint_adsorbate', '10-eint_slab'.\"\n                )\n    else:\n        job_params = {}\n\n    # Try to read in completed calculations from the calc_dir\n    dft_ensemble_results = read_completed_calculations(\n        calc_dir, xc_ensemble, vib_xc_ensemble, freeze_surface_vib\n    )\n\n    for xc_func, xc_func_kwargs in xc_ensemble.items():\n        # relax molecule\n        if dft_ensemble_results[\"01-molecule\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"01-molecule\", {}), **xc_func_kwargs}\n            dft_ensemble_results[\"01-molecule\"][xc_func] = relax_job(\n                adsorbate,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"01-molecule\", xc_func)\n                },\n                pmg_kpts={\"kppvol\": 1},\n                **calc_kwargs,\n            )\n\n        # relax solid\n        if dft_ensemble_results[\"02-unit_cell\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"02-unit_cell\", {}), **xc_func_kwargs}\n            relax_job1 = relax_job(\n                unit_cell,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"02-unit_cell\", xc_func)\n                },\n                relax_cell=True,\n                unique_dir=True,\n                **calc_kwargs,\n            )\n            dft_ensemble_results[\"02-unit_cell\"][xc_func] = relax_job(\n                relax_job1[\"atoms\"],\n                relax_cell=True,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"02-unit_cell\", xc_func),\n                    \"relax1\": relax_job1,\n                },\n                **calc_kwargs,\n            )\n\n        # bulk to slab\n        if dft_ensemble_results[\"03-slab\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"03-slab\", {}), **xc_func_kwargs}\n            initial_slab = slab_gen_func(\n                dft_ensemble_results[\"02-unit_cell\"][xc_func][\"atoms\"]\n            )\n            dft_ensemble_results[\"03-slab\"][xc_func] = relax_job(\n                initial_slab,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"03-slab\", xc_func)\n                },\n                pmg_kpts={\"length_densities\": [50, 50, 1]},\n                **calc_kwargs,\n            )\n\n        # slab to ads_slab\n        if dft_ensemble_results[\"04-adsorbate_slab\"][xc_func] is None:\n            calc_kwargs = {**job_params.get(\"04-adsorbate_slab\", {}), **xc_func_kwargs}\n            initial_adsorbate_slab = adsorbate_slab_gen_func(\n                dft_ensemble_results[\"01-molecule\"][xc_func][\"atoms\"],\n                dft_ensemble_results[\"03-slab\"][xc_func][\"atoms\"],\n            )\n\n            dft_ensemble_results[\"04-adsorbate_slab\"][xc_func] = relax_job(\n                initial_adsorbate_slab,\n                additional_fields={\n                    \"calc_results_dir\": Path(calc_dir, \"04-adsorbate_slab\", xc_func)\n                },\n                pmg_kpts={\"length_densities\": [50, 50, 1]},\n                **calc_kwargs,\n            )\n\n        if xc_func in vib_xc_ensemble:\n            # vibrational calculation\n            if dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"05-adsorbate_slab_vib\", {}),\n                    **xc_func_kwargs,\n                }\n                adsorbate_slab_vib_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][\n                    xc_func\n                ][\"atoms\"]\n\n                if freeze_surface_vib:\n                    adsorbate_len = len(\n                        dft_ensemble_results[\"01-molecule\"][xc_func][\"atoms\"]\n                    )\n                    slab_indices = list(range(len(adsorbate_slab_vib_atoms)))[\n                        adsorbate_len:\n                    ]\n                    adsorbate_slab_vib_atoms.set_constraint(\n                        FixAtoms(indices=slab_indices)\n                    )\n\n                dft_ensemble_results[\"05-adsorbate_slab_vib\"][xc_func] = freq_job(\n                    adsorbate_slab_vib_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(\n                            calc_dir, \"05-adsorbate_slab_vib\", xc_func\n                        )\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n            if dft_ensemble_results[\"06-molecule_vib\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"06-molecule_vib\", {}),\n                    **xc_func_kwargs,\n                }\n                dft_ensemble_results[\"06-molecule_vib\"][xc_func] = freq_job(\n                    dft_ensemble_results[\"01-molecule\"][xc_func][\"atoms\"],\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"06-molecule_vib\", xc_func)\n                    },\n                    pmg_kpts={\"kppvol\": 1},\n                    **calc_kwargs,\n                )\n\n            if (\n                dft_ensemble_results[\"07-slab_vib\"][xc_func] is None\n                and freeze_surface_vib is False\n            ):\n                calc_kwargs = {**job_params.get(\"07-slab_vib\", {}), **xc_func_kwargs}\n                dft_ensemble_results[\"07-slab_vib\"][xc_func] = freq_job(\n                    dft_ensemble_results[\"03-slab\"][xc_func][\"atoms\"],\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"07-slab_vib\", xc_func)\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n    if geom_error_xc is not None:\n        adsorbate_len = len(dft_ensemble_results[\"01-molecule\"][geom_error_xc][\"atoms\"])\n        adsorbate_slab_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][geom_error_xc][\n            \"atoms\"\n        ]\n        fixed_adsorbate_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][\n            geom_error_xc\n        ][\"atoms\"][:adsorbate_len]\n        fixed_slab_atoms = dft_ensemble_results[\"04-adsorbate_slab\"][geom_error_xc][\n            \"atoms\"\n        ][adsorbate_len:]\n\n        for xc_func in xc_ensemble:\n            # eint on adsorbate_slab\n            if dft_ensemble_results[\"08-eint_adsorbate_slab\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"08-eint_adsorbate_slab\", {}),\n                    **xc_func_kwargs,\n                }\n                dft_ensemble_results[\"08-eint_adsorbate_slab\"][xc_func] = static_job(\n                    adsorbate_slab_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(\n                            calc_dir, \"08-eint_adsorbate_slab\", xc_func\n                        )\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n            # eint on adsorbate\n            if dft_ensemble_results[\"09-eint_adsorbate\"][xc_func] is None:\n                calc_kwargs = {\n                    **job_params.get(\"09-eint_adsorbate\", {}),\n                    **xc_func_kwargs,\n                }\n                dft_ensemble_results[\"09-eint_adsorbate\"][xc_func] = static_job(\n                    fixed_adsorbate_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"09-eint_adsorbate\", xc_func)\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n            # eint on slab\n            if dft_ensemble_results[\"10-eint_slab\"][xc_func] is None:\n                calc_kwargs = {**job_params.get(\"10-eint_slab\", {}), **xc_func_kwargs}\n                dft_ensemble_results[\"10-eint_slab\"][xc_func] = static_job(\n                    fixed_slab_atoms,\n                    additional_fields={\n                        \"calc_results_dir\": Path(calc_dir, \"10-eint_slab\", xc_func)\n                    },\n                    pmg_kpts={\"length_densities\": [50, 50, 1]},\n                    **calc_kwargs,\n                )\n\n    return dft_ensemble_results\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.freq_job","title":"freq_job","text":"<pre><code>freq_job(atoms: Atoms, preset: str | None = 'BulkSet', copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, additional_fields: dict[str, Any] | None = None, **calc_kwargs) -&gt; VaspSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'BulkSet'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>@job\ndef freq_job(\n    atoms: Atoms,\n    preset: str | None = \"BulkSet\",\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp](https://quantum-accelerators.github.io/quacc/reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp).\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run](https://quantum-accelerators.github.io/quacc/reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize).\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"encut\": 600,\n        \"ismear\": 0,\n        \"sigma\": 0.05,\n        \"ediff\": 1e-7,\n        \"algo\": \"ALL\",\n        \"istart\": 0,\n        \"lreal\": False,\n        \"ispin\": 1,\n        \"nelm\": 200,\n        \"nelmin\": 8,\n        \"ibrion\": 5,\n        \"potim\": 0.01,\n        \"nfree\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 0,\n        \"symprec\": 1e-8,\n    }\n\n    if \"calc_results_dir\" in additional_fields:\n        with change_settings(\n            {\n                \"RESULTS_DIR\": additional_fields[\"calc_results_dir\"],\n                \"CREATE_UNIQUE_DIR\": False,\n                \"GZIP_FILES\": False,\n            }\n        ):\n            results_dict = run_and_summarize(\n                atoms,\n                preset=preset,\n                calc_defaults=calc_defaults,\n                calc_swaps=calc_kwargs,\n                additional_fields={\"name\": \"VASP Freq\"} | (additional_fields or {}),\n                copy_files=copy_files,\n            )\n    else:\n        results_dict = run_and_summarize(\n            atoms,\n            preset=preset,\n            calc_defaults=calc_defaults,\n            calc_swaps=calc_kwargs,\n            additional_fields={\"name\": \"VASP Freq\"} | (additional_fields or {}),\n            copy_files=copy_files,\n        )\n\n    real_freqs, imag_freqs = read_vib_freq(results_dict[\"dir_name\"] / \"OUTCAR\")\n    results_dict[\"results\"][\"real_vib_freqs\"] = real_freqs\n    results_dict[\"results\"][\"imag_vib_freqs\"] = imag_freqs\n    results_dict[\"atoms\"] = resort_atoms(atoms, results_dict[\"atoms\"])\n    results_dict[\"atoms\"].set_constraint(atoms.constraints.copy())\n\n    return results_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.read_completed_calculations","title":"read_completed_calculations","text":"<pre><code>read_completed_calculations(calc_dir: Path | str, xc_ensemble: list[str] | dict[str, str], vib_xc_ensemble: list[str], freeze_surface_vib: bool) -&gt; dict[str, dict[str, VaspSchema]]\n</code></pre> <p>Read in the completed calculations from the calc_dir.</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>Path or str</code>)           \u2013            <p>The directory where the calculations were performed.</p> </li> <li> <code>xc_ensemble</code>               (<code>dict[str, str]</code>)           \u2013            <p>A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.</p> </li> <li> <code>vib_xc_ensemble</code>               (<code>list[str]</code>)           \u2013            <p>A list of xc functionals for which the vibrational calculations were performed.</p> </li> <li> <code>freeze_surface_vib</code>               (<code>bool</code>)           \u2013            <p>True if the vibrational calculations on the slab should be skipped.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, VaspSchema]]</code>           \u2013            <p>A dictionary containing the results of the DFT ensemble calculations for each functional in the ensemble.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>def read_completed_calculations(\n    calc_dir: Path | str,\n    xc_ensemble: list[str] | dict[str, str],\n    vib_xc_ensemble: list[str],\n    freeze_surface_vib: bool,\n) -&gt; dict[str, dict[str, VaspSchema]]:\n    \"\"\"\n    Read in the completed calculations from the calc_dir.\n\n    Parameters\n    ----------\n    calc_dir : Path or str\n        The directory where the calculations were performed.\n    xc_ensemble : dict[str, str]\n        A dictionary containing the xc functionals to be used as keys and the corresponding settings as values.\n    vib_xc_ensemble : list[str]\n        A list of xc functionals for which the vibrational calculations were performed.\n    freeze_surface_vib : bool\n        True if the vibrational calculations on the slab should be skipped.\n\n    Returns\n    -------\n    dict[str, dict[str,VaspSchema]]\n        A dictionary containing the results of the DFT ensemble calculations for each functional in the ensemble.\n\n    \"\"\"\n    job_list = [\n        \"01-molecule\",\n        \"02-unit_cell\",\n        \"03-slab\",\n        \"04-adsorbate_slab\",\n        \"05-adsorbate_slab_vib\",\n        \"06-molecule_vib\",\n        \"07-slab_vib\",\n        \"08-eint_adsorbate_slab\",\n        \"09-eint_adsorbate\",\n        \"10-eint_slab\",\n    ]\n\n    dft_ensemble_results = {\n        job_type: dict.fromkeys(xc_ensemble) for job_type in job_list\n    }\n    for xc_func in xc_ensemble:\n        for job_type in job_list:\n            vasp_dir = Path(calc_dir) / job_type / xc_func\n            outcar_filename = Path(calc_dir) / job_type / xc_func / \"OUTCAR\"\n            if outcar_filename.exists():\n                if \"vib\" in job_type:\n                    if xc_func not in vib_xc_ensemble or (\n                        freeze_surface_vib and \"07-slab_vib\" in job_type\n                    ):\n                        continue\n                    with Path.open(outcar_filename, encoding=\"ISO-8859-1\") as file:\n                        final_atoms = read(file, format=\"vasp-out\")\n                        real_vib_freqs, imag_vib_freqs = read_vib_freq(outcar_filename)\n                        final_atoms.calc.results[\"real_vib_freqs\"] = real_vib_freqs\n                        final_atoms.calc.results[\"imag_vib_freqs\"] = imag_vib_freqs\n                else:\n                    with Path.open(outcar_filename, encoding=\"ISO-8859-1\") as file:\n                        final_atoms = read(file, format=\"vasp-out\")\n\n                dft_ensemble_results[job_type][xc_func] = Summarize(\n                    directory=vasp_dir\n                ).run(final_atoms, final_atoms)\n    return dft_ensemble_results\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.read_vib_freq","title":"read_vib_freq","text":"<pre><code>read_vib_freq(filename)\n</code></pre> <p>Read vibrational frequencies from a file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The name of the file to read vibrational frequencies from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>freq</code> (              <code>list</code> )          \u2013            <p>List of real vibrational frequencies.</p> </li> <li> <code>i_freq</code> (              <code>list</code> )          \u2013            <p>List of imaginary vibrational frequencies.</p> </li> </ul> Notes <p>This function reads vibrational frequency information from a given file. It extracts both real and imaginary vibrational frequencies from the lines containing the frequency data. The frequencies are extracted based on the presence of \"THz\" in the data. Real frequencies are extracted unless the \"f/i=\" label is found, in which case imaginary frequencies are extracted. The function returns two lists containing the real and imaginary frequencies respectively.</p> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>def read_vib_freq(filename):\n    \"\"\"\n    Read vibrational frequencies from a file.\n\n    Parameters\n    ----------\n    filename : str\n        The name of the file to read vibrational frequencies from.\n\n    Returns\n    -------\n    freq : list\n        List of real vibrational frequencies.\n    i_freq : list\n        List of imaginary vibrational frequencies.\n\n    Notes\n    -----\n    This function reads vibrational frequency information from a given file. It extracts both real and imaginary vibrational frequencies from the lines containing the frequency data. The frequencies are extracted based on the presence of \"THz\" in the data. Real frequencies are extracted unless the \"f/i=\" label is found, in which case imaginary frequencies are extracted. The function returns two lists containing the real and imaginary frequencies respectively.\n    \"\"\"\n\n    freq = []\n    i_freq = []\n\n    with Path.open(filename, encoding=\"ISO-8859-1\") as f:\n        lines = f.readlines()\n\n    for line in lines:\n        data = line.split()\n        if \"THz\" in data:\n            if \"f/i=\" not in data:\n                freq.append(float(data[-2]))  # Append real frequency to the freq list\n            else:\n                i_freq.append(\n                    float(data[-2])\n                )  # Append imaginary frequency to the i_freq list\n    return freq, i_freq\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.relax_job","title":"relax_job","text":"<pre><code>relax_job(atoms: Atoms, preset: str | None = 'BulkSet', relax_cell: bool = False, copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, additional_fields: dict[str, Any] | None = None, unique_dir: bool = False, **calc_kwargs) -&gt; VaspSchema\n</code></pre> <p>Relax a structure.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'BulkSet'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>relax_cell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>True if a volume relaxation (ISIF = 3) should be performed. False if only the positions (ISIF = 2) should be updated.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to the quacc.calculators.vasp.vasp.Vasp calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>@job\ndef relax_job(\n    atoms: Atoms,\n    preset: str | None = \"BulkSet\",\n    relax_cell: bool = False,\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    unique_dir: bool = False,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Relax a structure.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    relax_cell\n        True if a volume relaxation (ISIF = 3) should be performed. False if\n        only the positions (ISIF = 2) should be updated.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to the [quacc.calculators.vasp.vasp.Vasp](https://quantum-accelerators.github.io/quacc/reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp) calculator.\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run](https://quantum-accelerators.github.io/quacc/reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize).\n        See the type-hint for the data structure.\n    \"\"\"\n\n    calc_defaults = {\n        \"encut\": 600,\n        \"ismear\": 0,\n        \"sigma\": 0.05,\n        \"ediff\": 5e-7,\n        \"algo\": \"ALL\",\n        \"istart\": 0,\n        \"lreal\": False,\n        \"ispin\": 1,\n        \"nelm\": 200,\n        \"nelmin\": 8,\n        \"ediffg\": -0.01,\n        \"isif\": 3 if relax_cell else 2,\n        \"ibrion\": 2,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 200,\n        \"symprec\": 1e-8,\n    }\n\n    if \"calc_results_dir\" in additional_fields:\n        with change_settings(\n            {\n                \"RESULTS_DIR\": additional_fields[\"calc_results_dir\"],\n                \"CREATE_UNIQUE_DIR\": unique_dir,\n                \"GZIP_FILES\": False,\n            }\n        ):\n            results_dict = run_and_summarize(\n                atoms,\n                preset=preset,\n                calc_defaults=calc_defaults,\n                calc_swaps=calc_kwargs,\n                additional_fields={\"name\": \"VASP Relax\"} | (additional_fields or {}),\n                copy_files=copy_files,\n            )\n    else:\n        results_dict = run_and_summarize(\n            atoms,\n            preset=preset,\n            calc_defaults=calc_defaults,\n            calc_swaps=calc_kwargs,\n            additional_fields={\"name\": \"VASP Relax\"} | (additional_fields or {}),\n            copy_files=copy_files,\n        )\n\n    results_dict[\"atoms\"] = resort_atoms(atoms, results_dict[\"atoms\"])\n    results_dict[\"atoms\"].set_constraint(atoms.constraints.copy())\n\n    return results_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.resort_atoms","title":"resort_atoms","text":"<pre><code>resort_atoms(initial_atoms: Atoms, final_atoms: Atoms) -&gt; Atoms\n</code></pre> <p>Resorts the atoms in the final_atoms object to match the order of the initial_atoms object.</p> <p>Parameters:</p> <ul> <li> <code>initial_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The initial Atoms object prior to entering the ASE calculator.</p> </li> <li> <code>final_atoms</code>               (<code>Atoms</code>)           \u2013            <p>The final Atoms object after being run by the ASE calculator.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Atoms</code>           \u2013            <p>The final Atoms object with the atoms in the same order as the initial Atoms object.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>def resort_atoms(initial_atoms: Atoms, final_atoms: Atoms) -&gt; Atoms:\n    \"\"\"\n    Resorts the atoms in the final_atoms object to match the order of the initial_atoms object.\n\n    Parameters\n    ----------\n    initial_atoms : Atoms\n        The initial Atoms object prior to entering the ASE calculator.\n    final_atoms : Atoms\n        The final Atoms object after being run by the ASE calculator.\n\n    Returns\n    -------\n    Atoms\n        The final Atoms object with the atoms in the same order as the initial Atoms object.\n\n    \"\"\"\n    symbols, _ = count_symbols(initial_atoms, exclude=())\n\n    # Create sorting list\n    srt = []  # type: list[int]\n\n    for symbol in symbols:\n        for m, atom in enumerate(initial_atoms):\n            if atom.symbol == symbol:\n                srt.append(m)\n    # Create the resorting list\n    resrt = list(range(len(srt)))\n    for n in range(len(resrt)):\n        resrt[srt[n]] = n\n\n    resorted_final_atoms = final_atoms.copy()[srt]\n    if hasattr(final_atoms, \"calc\"):\n        resorted_final_atoms.calc = final_atoms.calc\n\n    return resorted_final_atoms\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_dft.html#autoSKZCAM.recipes_dft.static_job","title":"static_job","text":"<pre><code>static_job(atoms: Atoms, preset: str | None = 'BulkSet', copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None, additional_fields: dict[str, Any] | None = None, **calc_kwargs) -&gt; VaspSchema\n</code></pre> <p>Carry out a single-point calculation.</p> <p>Parameters:</p> <ul> <li> <code>atoms</code>               (<code>Atoms</code>)           \u2013            <p>Atoms object</p> </li> <li> <code>preset</code>               (<code>str | None</code>, default:                   <code>'BulkSet'</code> )           \u2013            <p>Preset to use from <code>quacc.calculators.vasp.presets</code>.</p> </li> <li> <code>copy_files</code>               (<code>SourceDirectory | dict[SourceDirectory, Filenames] | None</code>, default:                   <code>None</code> )           \u2013            <p>Files to copy (and decompress) from source to the runtime directory.</p> </li> <li> <code>additional_fields</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional fields to add to the results dictionary.</p> </li> <li> <code>**calc_kwargs</code>           \u2013            <p>Custom kwargs for the Vasp calculator. Set a value to <code>None</code> to remove a pre-existing key entirely. For a list of available keys, refer to quacc.calculators.vasp.vasp.Vasp.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>VaspSchema</code>           \u2013            <p>Dictionary of results from quacc.schemas.vasp.VaspSummarize.run. See the type-hint for the data structure.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_dft.py</code> <pre><code>@job\ndef static_job(\n    atoms: Atoms,\n    preset: str | None = \"BulkSet\",\n    copy_files: SourceDirectory | dict[SourceDirectory, Filenames] | None = None,\n    additional_fields: dict[str, Any] | None = None,\n    **calc_kwargs,\n) -&gt; VaspSchema:\n    \"\"\"\n    Carry out a single-point calculation.\n\n    Parameters\n    ----------\n    atoms\n        Atoms object\n    preset\n        Preset to use from `quacc.calculators.vasp.presets`.\n    copy_files\n        Files to copy (and decompress) from source to the runtime directory.\n    additional_fields\n        Additional fields to add to the results dictionary.\n    **calc_kwargs\n        Custom kwargs for the Vasp calculator. Set a value to\n        `None` to remove a pre-existing key entirely. For a list of available\n        keys, refer to [quacc.calculators.vasp.vasp.Vasp](https://quantum-accelerators.github.io/quacc/reference/quacc/calculators/vasp/vasp.html#quacc.calculators.vasp.vasp.Vasp).\n\n    Returns\n    -------\n    VaspSchema\n        Dictionary of results from [quacc.schemas.vasp.VaspSummarize.run](https://quantum-accelerators.github.io/quacc/reference/quacc/schemas/vasp.html#quacc.schemas.vasp.VaspSummarize).\n        See the type-hint for the data structure.\n    \"\"\"\n    calc_defaults = {\n        \"encut\": 600,\n        \"ismear\": 0,\n        \"sigma\": 0.05,\n        \"ediff\": 5e-7,\n        \"algo\": \"ALL\",\n        \"istart\": 0,\n        \"lreal\": False,\n        \"ispin\": 1,\n        \"nelm\": 200,\n        \"nelmin\": 8,\n        \"ibrion\": -1,\n        \"isym\": 0,\n        \"lcharg\": False,\n        \"lwave\": False,\n        \"nsw\": 0,\n        \"symprec\": 1e-8,\n    }\n\n    if \"calc_results_dir\" in additional_fields:\n        with change_settings(\n            {\n                \"RESULTS_DIR\": additional_fields[\"calc_results_dir\"],\n                \"CREATE_UNIQUE_DIR\": False,\n                \"GZIP_FILES\": False,\n            }\n        ):\n            results_dict = run_and_summarize(\n                atoms,\n                preset=preset,\n                calc_defaults=calc_defaults,\n                calc_swaps=calc_kwargs,\n                additional_fields={\"name\": \"VASP Static\"} | (additional_fields or {}),\n                copy_files=copy_files,\n            )\n    else:\n        results_dict = run_and_summarize(\n            atoms,\n            preset=preset,\n            calc_defaults=calc_defaults,\n            calc_swaps=calc_kwargs,\n            additional_fields={\"name\": \"VASP Static\"} | (additional_fields or {}),\n            copy_files=copy_files,\n        )\n\n    results_dict[\"atoms\"] = resort_atoms(atoms, results_dict[\"atoms\"])\n    results_dict[\"atoms\"].set_constraint(atoms.constraints.copy())\n\n    return results_dict\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_skzcam.html","title":"recipes_skzcam","text":""},{"location":"reference/autoSKZCAM/recipes_skzcam.html#autoSKZCAM.recipes_skzcam.skzcam_analyse","title":"skzcam_analyse","text":"<pre><code>skzcam_analyse(calc_dir: str | Path, embedded_cluster_npy_path: Path | str | None = None, OniomInfo: dict[str, OniomLayerInfo] | None = None, EmbeddedCluster: CreateEmbeddedCluster | None = None) -&gt; dict[str, tuple[float, float]]\n</code></pre> <p>Analyze the completed SKZCAM calculations and compute the final ONIOM contributions.</p> <p>Parameters:</p> <ul> <li> <code>calc_dir</code>               (<code>str | Path</code>)           \u2013            <p>The directory containing the calculations.</p> </li> <li> <code>embedded_cluster_npy_path</code>               (<code>Path | str | None</code>, default:                   <code>None</code> )           \u2013            <p>The path to the embedded cluster .npy object.</p> </li> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster | None</code>, default:                   <code>None</code> )           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster.</p> </li> <li> <code>OniomInfo</code>               (<code>dict[str, OniomLayerInfo] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary containing the information about the ONIOM layers.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, tuple[float, float]]</code>           \u2013            <p>A dictionary containing the ONIOM layer as key and a tuple containing the contribution to the final interaction energy as well as its error.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_analyse(\n    calc_dir: str | Path,\n    embedded_cluster_npy_path: Path | str | None = None,\n    OniomInfo: dict[str, OniomLayerInfo] | None = None,\n    EmbeddedCluster: CreateEmbeddedCluster | None = None,\n) -&gt; dict[str, tuple[float, float]]:\n    \"\"\"\n    Analyze the completed SKZCAM calculations and compute the final ONIOM contributions.\n\n    Parameters\n    ----------\n    calc_dir\n        The directory containing the calculations.\n    embedded_cluster_npy_path\n        The path to the embedded cluster .npy object.\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster.\n    OniomInfo\n        A dictionary containing the information about the ONIOM layers.\n\n    Returns\n    -------\n    dict[str, tuple[float, float]]\n        A dictionary containing the ONIOM layer as key and a tuple containing the contribution to the final interaction energy as well as its error.\n    \"\"\"\n\n    # Initialize the EmbeddedCluster object if it is not provided\n    if EmbeddedCluster is None and embedded_cluster_npy_path is None:\n        # Check if the embedded_cluster.npy file exists in the calc_dir\n        if not Path(calc_dir, \"embedded_cluster.npy\").exists():\n            raise ValueError(\n                \"Either the EmbeddedCluster object must be provided or embedded_cluster_npy_path is set or embedded_cluster.npy is provided in calc_dir.\"\n            )\n        EmbeddedCluster = np.load(\n            Path(calc_dir, \"embedded_cluster.npy\"), allow_pickle=True\n        ).item()\n\n    elif EmbeddedCluster is None and embedded_cluster_npy_path is not None:\n        EmbeddedCluster = np.load(embedded_cluster_npy_path, allow_pickle=True).item()\n\n    # Load the OniomInfo dictionary if it is not provided\n    if EmbeddedCluster.OniomInfo is None:\n        if OniomInfo is None:\n            raise ValueError(\n                \"The OniomInfo dictionary must be provided in EmbeddedCluster or as an argument.\"\n            )\n        EmbeddedCluster.OniomInfo = OniomInfo\n\n    if EmbeddedCluster.OniomInfo is not None and OniomInfo is None:\n        OniomInfo = EmbeddedCluster.OniomInfo\n\n    skzcam_calcs_analysis = analyze_calculations(\n        calc_dir=calc_dir,\n        embedded_cluster_path=embedded_cluster_npy_path,\n        EmbeddedCluster=EmbeddedCluster,\n    )\n\n    return compute_skzcam_int_ene(\n        skzcam_calcs_analysis=skzcam_calcs_analysis, OniomInfo=OniomInfo\n    )\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_skzcam.html#autoSKZCAM.recipes_skzcam.skzcam_calculate_job","title":"skzcam_calculate_job","text":"<pre><code>skzcam_calculate_job(EmbeddedCluster: CreateEmbeddedCluster, OniomInfo: dict[str, str], dryrun: bool = False, use_quacc: bool = False, calc_dir: str | Path = 'calc_dir', capped_ecp: dict[Literal['mrcc', 'orca'], str] | None = None, **kwargs) -&gt; CalculatorInfo\n</code></pre> <p>Perform the skzcam calculations on the embedded clusters.</p> <p>Parameters:</p> <ul> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster</code>)           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster.</p> </li> <li> <code>OniomInfo</code>               (<code>dict[str, str]</code>)           \u2013            <p>A dictionary containing the information about the ONIOM layers.</p> </li> <li> <code>dryrun</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the input files will be written but the calculations will not be performed.</p> </li> <li> <code>use_quacc</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the calculations will be performed using QuaCC.</p> </li> <li> <code>calc_dir</code>               (<code>str | Path</code>, default:                   <code>'calc_dir'</code> )           \u2013            <p>The directory where the calculations will be performed.</p> </li> <li> <code>capped_ecp</code>               (<code>dict[Literal['mrcc', 'orca'], str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary containing the ECPs for the MRCC and ORCA calculations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CalculatorInfo</code>           \u2013            <p>A dictionary containing the cluster number as key and a dictionary of ASE calculators for the calculations that have been performed.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_calculate_job(\n    EmbeddedCluster: CreateEmbeddedCluster,\n    OniomInfo: dict[str, str],\n    dryrun: bool = False,\n    use_quacc: bool = False,\n    calc_dir: str | Path = \"calc_dir\",\n    capped_ecp: dict[Literal[\"mrcc\", \"orca\"], str] | None = None,\n    **kwargs,  # noqa ARG001\n) -&gt; CalculatorInfo:\n    \"\"\"\n    Perform the skzcam calculations on the embedded clusters.\n\n    Parameters\n    ----------\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster.\n    OniomInfo\n        A dictionary containing the information about the ONIOM layers.\n    dryrun\n        If True, the input files will be written but the calculations will not be performed.\n    use_quacc\n        If True, the calculations will be performed using QuaCC.\n    calc_dir\n        The directory where the calculations will be performed.\n    capped_ecp\n        A dictionary containing the ECPs for the MRCC and ORCA calculations.\n\n    Returns\n    -------\n    CalculatorInfo\n        A dictionary containing the cluster number as key and a dictionary of ASE calculators for the calculations that have been performed.\n    \"\"\"\n\n    # Prepare the embedded cluster for the calculations\n    Prepare(\n        EmbeddedCluster=EmbeddedCluster, OniomInfo=OniomInfo, capped_ecp=capped_ecp\n    ).create_cluster_calcs()\n\n    # Set the OniomInfo attribute\n    EmbeddedCluster.OniomInfo = OniomInfo\n\n    if dryrun:\n        skzcam_write_inputs(EmbeddedCluster, calc_dir)\n    else:\n        skzcam_write_inputs(EmbeddedCluster, calc_dir)\n        for cluster_num in EmbeddedCluster.skzcam_calcs:\n            for calculation_label in EmbeddedCluster.skzcam_calcs[cluster_num]:\n                code = calculation_label.split()[0]\n                method = calculation_label.split()[1]\n                frozen_core = calculation_label.split()[2]\n                basis_set = calculation_label.split()[3]\n                for structure in [\"adsorbate\", \"slab\", \"adsorbate_slab\"]:\n                    system_path = Path(\n                        calc_dir,\n                        str(cluster_num),\n                        code,\n                        f\"{method}_{basis_set}_{frozen_core}\",\n                        structure,\n                    )\n                    EmbeddedCluster.skzcam_calcs[cluster_num][calculation_label][\n                        structure\n                    ].calc.directory = system_path\n                    # Check whether the calculation has already been performed\n                    if code == \"mrcc\":\n                        # Simply read calculation if it has already been performed\n                        if Path(system_path, \"mrcc.out\").exists():\n                            final_energy = parse_energy(\n                                Path(system_path, \"mrcc.out\"), code=code\n                            )\n                            EmbeddedCluster.skzcam_calcs[cluster_num][\n                                calculation_label\n                            ][structure].results = final_energy\n\n                        else:\n                            if use_quacc:\n                                calc_parameters = EmbeddedCluster.skzcam_calcs[\n                                    cluster_num\n                                ][calculation_label][structure].calc.parameters\n                                with change_settings(\n                                    {\n                                        \"RESULTS_DIR\": system_path,\n                                        \"CREATE_UNIQUE_DIR\": False,\n                                        \"GZIP_FILES\": False,\n                                    }\n                                ):\n                                    static_job_mrcc(\n                                        EmbeddedCluster.skzcam_calcs[cluster_num][\n                                            calculation_label\n                                        ][structure],\n                                        **calc_parameters,\n                                    )\n                            else:\n                                EmbeddedCluster.skzcam_calcs[cluster_num][\n                                    calculation_label\n                                ][structure].get_potential_energy()\n                    elif code == \"orca\":\n                        if Path(system_path, \"orca.out\").exists():\n                            final_energy = parse_energy(\n                                Path(system_path, \"orca.out\"), code=code\n                            )\n                            EmbeddedCluster.skzcam_calcs[cluster_num][\n                                calculation_label\n                            ][structure].results = final_energy\n                        else:\n                            if use_quacc:\n                                calc_parameters = EmbeddedCluster.skzcam_calcs[\n                                    cluster_num\n                                ][calculation_label][structure].calc.parameters\n                                with change_settings(\n                                    {\n                                        \"RESULTS_DIR\": system_path,\n                                        \"CREATE_UNIQUE_DIR\": False,\n                                        \"GZIP_FILES\": False,\n                                    }\n                                ):\n                                    static_job_orca(\n                                        EmbeddedCluster.skzcam_calcs[cluster_num][\n                                            calculation_label\n                                        ][structure],\n                                        **calc_parameters,\n                                    )\n                            else:\n                                EmbeddedCluster.skzcam_calcs[cluster_num][\n                                    calculation_label\n                                ][structure].get_potential_energy()\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_skzcam.html#autoSKZCAM.recipes_skzcam.skzcam_eint_flow","title":"skzcam_eint_flow","text":"<pre><code>skzcam_eint_flow(EmbeddedCluster: CreateEmbeddedCluster, OniomInfo: dict[str, OniomLayerInfo], capped_ecp: dict[Literal['mrcc', 'orca'], str] | None = None, **kwargs) -&gt; None\n</code></pre> <p>The complete SKZCAM protocol to generate the embedded clusters, perform the calculations, and analyze the results.</p> <p>Parameters:</p> <ul> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster</code>)           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster. This is initialised using the skzcam_initialise() function.</p> </li> <li> <code>OniomInfo</code>               (<code>dict[str, OniomLayerInfo]</code>)           \u2013            <p>A dictionary containing the information about the ONIOM layers.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional keyword arguments to pass to the skzcam_generate_job() and skzcam_calculate_job() functions.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_eint_flow(\n    EmbeddedCluster: CreateEmbeddedCluster,\n    OniomInfo: dict[str, OniomLayerInfo],\n    capped_ecp: dict[Literal[\"mrcc\", \"orca\"], str] | None = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    The complete SKZCAM protocol to generate the embedded clusters, perform the calculations, and analyze the results.\n\n    Parameters\n    ----------\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster. This is initialised using the skzcam_initialise() function.\n    OniomInfo\n        A dictionary containing the information about the ONIOM layers.\n    **kwargs\n        Additional keyword arguments to pass to the skzcam_generate_job() and skzcam_calculate_job() functions.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # Generate the skzcam embedded clusters\n    skzcam_generate_job(EmbeddedCluster, **kwargs)\n\n    # Perform the calculations on the embedded clusters\n    skzcam_calculate_job(EmbeddedCluster, OniomInfo, capped_ecp=capped_ecp, **kwargs)\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_skzcam.html#autoSKZCAM.recipes_skzcam.skzcam_generate_job","title":"skzcam_generate_job","text":"<pre><code>skzcam_generate_job(EmbeddedCluster: CreateEmbeddedCluster, max_cluster_num: int = 10, shell_width: float = 0.1, bond_dist: float = 2.5, ecp_dist: float = 6.0, write_clusters: bool = False, write_clusters_path: str | Path = '.', write_include_ecp: bool = False, **kwargs) -&gt; SkzcamOutput\n</code></pre> <p>Generates the set of clusters for the SKZCAM protocol. It will return the embedded cluster Atoms object and the indices of the atoms in the quantum clusters and the ECP region. The number of clusters created is controlled by the max_cluster_num parameter.</p> <p>Parameters:</p> <ul> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster</code>)           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster.</p> </li> <li> <code>max_cluster_num</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of quantum clusters to be created.</p> </li> <li> <code>shell_width</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Defines the distance between atoms within shells; this is the maximum distance between any two atoms within the shell.</p> </li> <li> <code>bond_dist</code>               (<code>float</code>, default:                   <code>2.5</code> )           \u2013            <p>The distance within which an anion is considered to be coordinating a cation.</p> </li> <li> <code>ecp_dist</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>The distance from edges of the quantum cluster to define the ECP region.</p> </li> <li> <code>write_clusters</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the quantum clusters will be written to a file.</p> </li> <li> <code>write_clusters_path</code>               (<code>str | Path</code>, default:                   <code>'.'</code> )           \u2013            <p>The path to the file where the quantum clusters will be written.</p> </li> <li> <code>write_include_ecp</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the ECP region will be included in the quantum clusters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SkzcamOutput</code>           \u2013            <p>A dictionary containing the embedded cluster Atoms object, the indices of the atoms in the quantum clusters, and the indices of the atoms in the ECP region.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_generate_job(\n    EmbeddedCluster: CreateEmbeddedCluster,\n    max_cluster_num: int = 10,\n    shell_width: float = 0.1,\n    bond_dist: float = 2.5,\n    ecp_dist: float = 6.0,\n    write_clusters: bool = False,\n    write_clusters_path: str | Path = \".\",\n    write_include_ecp: bool = False,\n    **kwargs,  # noqa ARG001\n) -&gt; SkzcamOutput:\n    \"\"\"\n    Generates the set of clusters for the SKZCAM protocol. It will return the embedded cluster Atoms object and the indices of the atoms in the quantum clusters and the ECP region. The number of clusters created is controlled by the max_cluster_num parameter.\n\n    Parameters\n    ----------\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster.\n    max_cluster_num\n        The maximum number of quantum clusters to be created.\n    shell_width\n        Defines the distance between atoms within shells; this is the maximum distance between any two atoms within the shell.\n    bond_dist\n        The distance within which an anion is considered to be coordinating a cation.\n    ecp_dist\n        The distance from edges of the quantum cluster to define the ECP region.\n    write_clusters\n        If True, the quantum clusters will be written to a file.\n    write_clusters_path\n        The path to the file where the quantum clusters will be written.\n    write_include_ecp\n        If True, the ECP region will be included in the quantum clusters.\n\n    Returns\n    -------\n    SkzcamOutput\n        A dictionary containing the embedded cluster Atoms object, the indices of the atoms in the quantum clusters, and the indices of the atoms in the ECP region.\n    \"\"\"\n\n    # Ensure that the pun_filepath has been provided in EmbeddedCluster\n    if (\n        not hasattr(EmbeddedCluster, \"pun_filepath\")\n        or EmbeddedCluster.pun_filepath is None\n    ):\n        raise ValueError(\n            \"The path pun_filepath to the .pun file from ChemShell must be provided in EmbeddedCluster.\"\n        )\n\n    # Generate the embedded cluster\n    EmbeddedCluster.run_skzcam(\n        shell_max=max_cluster_num,\n        shell_width=shell_width,\n        bond_dist=bond_dist,\n        ecp_dist=ecp_dist,\n        write_clusters=write_clusters,\n        write_clusters_path=write_clusters_path,\n        write_include_ecp=write_include_ecp,\n    )\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_skzcam.html#autoSKZCAM.recipes_skzcam.skzcam_initialise","title":"skzcam_initialise","text":"<pre><code>skzcam_initialise(adsorbate_indices: list[int], slab_center_indices: list[int], atom_oxi_states: dict[ElementStr, int], adsorbate_slab_file: str | Path, pun_filepath: str | Path = './ChemShell_EmbeddedCluster.pun', run_chemshell: bool = False, chemsh_radius_active: float = 40.0, chemsh_radius_cluster: float = 60.0, chemsh_bq_layer: float = 6.0, write_xyz_file: bool = False, **kwargs) -&gt; CreateEmbeddedCluster\n</code></pre> <p>Parameters to initialise the SKZCAM protocol to generate the embedded clusters.</p> <p>Parameters:</p> <ul> <li> <code>adsorbate_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms that make up the adsorbate molecule.</p> </li> <li> <code>slab_center_indices</code>               (<code>list[int]</code>)           \u2013            <p>The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.</p> </li> <li> <code>atom_oxi_states</code>               (<code>dict[ElementStr, int]</code>)           \u2013            <p>A dictionary with the element symbol as the key and its oxidation state as the value.</p> </li> <li> <code>adsorbate_slab_file</code>               (<code>str | Path</code>)           \u2013            <p>The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.</p> </li> <li> <code>pun_filepath</code>               (<code>str | Path</code>, default:                   <code>'./ChemShell_EmbeddedCluster.pun'</code> )           \u2013            <p>The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex if it has already been generated by ChemShell. If it is None, then ChemShell will need to be used to create this file.</p> </li> <li> <code>run_chemshell</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the ChemShell calculations will be run to generate the .pun file.</p> </li> <li> <code>chemsh_radius_active</code>               (<code>float</code>, default:                   <code>40.0</code> )           \u2013            <p>The radius of the active region in Angstroms. This 'active' region is simply region where the charge fitting is performed to ensure correct Madelung potential; it can be a relatively large value.</p> </li> <li> <code>chemsh_radius_cluster</code>               (<code>float</code>, default:                   <code>60.0</code> )           \u2013            <p>The radius of the total embedded cluster in Angstroms.</p> </li> <li> <code>chemsh_bq_layer</code>               (<code>float</code>, default:                   <code>6.0</code> )           \u2013            <p>The height above the surface to place some additional fitting point charges in Angstroms; simply for better reproduction of the electrostatic potential close to the adsorbate.</p> </li> <li> <code>write_xyz_file</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, the .xyz file will be written containing the atomic coordinates of the adsorbate-slab complex.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>CreateEmbeddedCluster</code>           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster.</p> </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_initialise(\n    adsorbate_indices: list[int],\n    slab_center_indices: list[int],\n    atom_oxi_states: dict[ElementStr, int],\n    adsorbate_slab_file: str | Path,\n    pun_filepath: str | Path = \"./ChemShell_EmbeddedCluster.pun\",\n    run_chemshell: bool = False,\n    chemsh_radius_active: float = 40.0,\n    chemsh_radius_cluster: float = 60.0,\n    chemsh_bq_layer: float = 6.0,\n    write_xyz_file: bool = False,\n    **kwargs,  # noqa ARG001\n) -&gt; CreateEmbeddedCluster:\n    \"\"\"\n    Parameters to initialise the SKZCAM protocol to generate the embedded clusters.\n\n    Parameters\n    ----------\n    adsorbate_indices\n        The indices of the atoms that make up the adsorbate molecule.\n    slab_center_indices\n        The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.\n    atom_oxi_states\n        A dictionary with the element symbol as the key and its oxidation state as the value.\n    adsorbate_slab_file\n        The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.\n    pun_filepath\n        The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex if it has already been generated by ChemShell. If it is None, then ChemShell will need to be used to create this file.\n    run_chemshell\n        If True, the ChemShell calculations will be run to generate the .pun file.\n    chemsh_radius_active\n        The radius of the active region in Angstroms. This 'active' region is simply region where the charge fitting is performed to ensure correct Madelung potential; it can be a relatively large value.\n    chemsh_radius_cluster\n        The radius of the total embedded cluster in Angstroms.\n    chemsh_bq_layer\n        The height above the surface to place some additional fitting point charges in Angstroms; simply for better reproduction of the electrostatic potential close to the adsorbate.\n    write_xyz_file\n        If True, the .xyz file will be written containing the atomic coordinates of the adsorbate-slab complex.\n\n    Returns\n    -------\n    CreateEmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster.\n\n    \"\"\"\n\n    EmbeddedCluster = CreateEmbeddedCluster(\n        adsorbate_indices=adsorbate_indices,\n        slab_center_indices=slab_center_indices,\n        atom_oxi_states=atom_oxi_states,\n        adsorbate_slab_file=adsorbate_slab_file,\n        pun_filepath=pun_filepath,\n    )\n\n    # Check that pun_filepath exists if run_chemshell is False\n    if run_chemshell is False and not Path(pun_filepath).exists():\n        raise ValueError(\n            \"The path to the .pun file from ChemShell must be provided in EmbeddedCluster if run_chemshell is False.\"\n        )\n\n    if run_chemshell:\n        # Create the ChemShell input file\n        EmbeddedCluster.run_chemshell(\n            filepath=pun_filepath,\n            chemsh_radius_active=chemsh_radius_active,\n            chemsh_radius_cluster=chemsh_radius_cluster,\n            chemsh_bq_layer=chemsh_bq_layer,\n            write_xyz_file=write_xyz_file,\n        )\n\n    return EmbeddedCluster\n</code></pre>"},{"location":"reference/autoSKZCAM/recipes_skzcam.html#autoSKZCAM.recipes_skzcam.skzcam_write_inputs","title":"skzcam_write_inputs","text":"<pre><code>skzcam_write_inputs(EmbeddedCluster: CreateEmbeddedCluster, input_dir: str | Path) -&gt; None\n</code></pre> <p>Generate the input files for the SKZCAM calculations.</p> <p>Parameters:</p> <ul> <li> <code>EmbeddedCluster</code>               (<code>CreateEmbeddedCluster</code>)           \u2013            <p>The CreateEmbeddedCluster object containing the embedded cluster.</p> </li> <li> <code>input_dir</code>               (<code>str | Path</code>)           \u2013            <p>The directory where the input files will be written.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>autoSKZCAM/recipes_skzcam.py</code> <pre><code>def skzcam_write_inputs(\n    EmbeddedCluster: CreateEmbeddedCluster, input_dir: str | Path\n) -&gt; None:\n    \"\"\"\n    Generate the input files for the SKZCAM calculations.\n\n    Parameters\n    ----------\n    EmbeddedCluster\n        The CreateEmbeddedCluster object containing the embedded cluster.\n    input_dir\n        The directory where the input files will be written.\n\n    Returns\n    -------\n    None\n    \"\"\"\n\n    # Confirm that skzcam_calcs is not None\n    if EmbeddedCluster.skzcam_calcs is None:\n        raise ValueError(\n            \"The EmbeddedCluster object must have the skzcam_calcs attribute set using oniom.Prepare.\"\n        )\n\n    skzcam_cluster_calculators = EmbeddedCluster.skzcam_calcs\n\n    for cluster_num in skzcam_cluster_calculators:\n        for calculation_label in skzcam_cluster_calculators[cluster_num]:\n            code = calculation_label.split()[0]\n            method = calculation_label.split()[1]\n            frozen_core = calculation_label.split()[2]\n            basis_set = calculation_label.split()[3]\n            for structure in [\"adsorbate\", \"slab\", \"adsorbate_slab\"]:\n                system_path = Path(\n                    input_dir,\n                    str(cluster_num),\n                    code,\n                    f\"{method}_{basis_set}_{frozen_core}\",\n                    structure,\n                )\n                system_path.mkdir(parents=True, exist_ok=True)\n                # Write MRCC input files\n                if code == \"mrcc\":\n                    calc_parameters = deepcopy(\n                        skzcam_cluster_calculators[cluster_num][calculation_label][\n                            structure\n                        ].calc.parameters\n                    )\n                    if \"genbas\" in calc_parameters:\n                        if calc_parameters[\"genbas\"] is not None:\n                            with Path.open(Path(system_path, \"GENBAS\"), \"w\") as f:\n                                f.write(calc_parameters[\"genbas\"])\n                        del calc_parameters[\"genbas\"]\n\n                    write_mrcc(\n                        Path(system_path, \"MINP\"),\n                        skzcam_cluster_calculators[cluster_num][calculation_label][\n                            structure\n                        ],\n                        calc_parameters,\n                    )\n\n                # Write ORCA input files\n                elif code == \"orca\":\n                    calc_parameters = deepcopy(\n                        skzcam_cluster_calculators[cluster_num][calculation_label][\n                            structure\n                        ].calc.parameters\n                    )\n\n                    if \"pointcharges\" in calc_parameters:\n                        if calc_parameters[\"pointcharges\"] is not None:\n                            with Path.open(Path(system_path, \"orca.pc\"), \"w\") as f:\n                                f.write(calc_parameters[\"pointcharges\"])\n                        del calc_parameters[\"pointcharges\"]\n\n                    write_orca(\n                        Path(system_path, \"orca.inp\"),\n                        skzcam_cluster_calculators[cluster_num][calculation_label][\n                            structure\n                        ],\n                        calc_parameters,\n                    )\n    np.save(Path(input_dir, \"embedded_cluster.npy\"), EmbeddedCluster)\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html","title":"types","text":""},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.ElementStr","title":"ElementStr  <code>module-attribute</code>","text":"<pre><code>ElementStr = Literal['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og']\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.BlockInfo","title":"BlockInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.BlockInfo.adsorbate","title":"adsorbate  <code>instance-attribute</code>","text":"<pre><code>adsorbate: str\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.BlockInfo.adsorbate_slab","title":"adsorbate_slab  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab: str\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.BlockInfo.slab","title":"slab  <code>instance-attribute</code>","text":"<pre><code>slab: str\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.CalculatorInfo","title":"CalculatorInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.CalculatorInfo.adsorbate","title":"adsorbate  <code>instance-attribute</code>","text":"<pre><code>adsorbate: Atoms\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.CalculatorInfo.adsorbate_slab","title":"adsorbate_slab  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab: Atoms\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.CalculatorInfo.slab","title":"slab  <code>instance-attribute</code>","text":"<pre><code>slab: Atoms\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.ElementInfo","title":"ElementInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.ElementInfo.basis","title":"basis  <code>instance-attribute</code>","text":"<pre><code>basis: str | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.ElementInfo.core","title":"core  <code>instance-attribute</code>","text":"<pre><code>core: int | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.ElementInfo.ecp","title":"ecp  <code>instance-attribute</code>","text":"<pre><code>ecp: str | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.ElementInfo.ri_cwft_basis","title":"ri_cwft_basis  <code>instance-attribute</code>","text":"<pre><code>ri_cwft_basis: str | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.ElementInfo.ri_scf_basis","title":"ri_scf_basis  <code>instance-attribute</code>","text":"<pre><code>ri_scf_basis: str | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EmbeddingInfo","title":"EmbeddingInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EmbeddingInfo.adsorbate_indices","title":"adsorbate_indices  <code>instance-attribute</code>","text":"<pre><code>adsorbate_indices: list[int]\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EmbeddingInfo.adsorbate_slab_file","title":"adsorbate_slab_file  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_file: str | Path\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EmbeddingInfo.atom_oxi_states","title":"atom_oxi_states  <code>instance-attribute</code>","text":"<pre><code>atom_oxi_states: dict[ElementStr, int]\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EmbeddingInfo.slab_center_indices","title":"slab_center_indices  <code>instance-attribute</code>","text":"<pre><code>slab_center_indices: list[int]\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EnergyInfo","title":"EnergyInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EnergyInfo.ccsd_corr_energy","title":"ccsd_corr_energy  <code>instance-attribute</code>","text":"<pre><code>ccsd_corr_energy: float | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EnergyInfo.ccsdt_corr_energy","title":"ccsdt_corr_energy  <code>instance-attribute</code>","text":"<pre><code>ccsdt_corr_energy: float | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EnergyInfo.energy","title":"energy  <code>instance-attribute</code>","text":"<pre><code>energy: float | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EnergyInfo.mp2_corr_energy","title":"mp2_corr_energy  <code>instance-attribute</code>","text":"<pre><code>mp2_corr_energy: float | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.EnergyInfo.scf_energy","title":"scf_energy  <code>instance-attribute</code>","text":"<pre><code>scf_energy: float | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MrccInputDict","title":"MrccInputDict","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MrccInputDict.adsorbate","title":"adsorbate  <code>instance-attribute</code>","text":"<pre><code>adsorbate: dict[str, str]\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MrccInputDict.adsorbate_slab","title":"adsorbate_slab  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab: dict[str, str]\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MrccInputDict.slab","title":"slab  <code>instance-attribute</code>","text":"<pre><code>slab: dict[str, str]\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MultiplicityDict","title":"MultiplicityDict","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MultiplicityDict.adsorbate","title":"adsorbate  <code>instance-attribute</code>","text":"<pre><code>adsorbate: int\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MultiplicityDict.adsorbate_slab","title":"adsorbate_slab  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab: int\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.MultiplicityDict.slab","title":"slab  <code>instance-attribute</code>","text":"<pre><code>slab: int\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo","title":"OniomLayerInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo.basis","title":"basis  <code>instance-attribute</code>","text":"<pre><code>basis: str\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Literal['mrcc', 'orca']\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo.code_inputs","title":"code_inputs  <code>instance-attribute</code>","text":"<pre><code>code_inputs: dict[str, str] | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo.element_info","title":"element_info  <code>instance-attribute</code>","text":"<pre><code>element_info: dict[ElementStr, ElementInfo] | None\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo.frozen_core","title":"frozen_core  <code>instance-attribute</code>","text":"<pre><code>frozen_core: Literal['valence', 'semicore']\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo.max_cluster_num","title":"max_cluster_num  <code>instance-attribute</code>","text":"<pre><code>max_cluster_num: int\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.OniomLayerInfo.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method: str\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamAnalysisInfo","title":"SkzcamAnalysisInfo","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamAnalysisInfo.adsorbate","title":"adsorbate  <code>instance-attribute</code>","text":"<pre><code>adsorbate: EnergyInfo\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamAnalysisInfo.adsorbate_slab","title":"adsorbate_slab  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab: EnergyInfo\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamAnalysisInfo.int_ene","title":"int_ene  <code>instance-attribute</code>","text":"<pre><code>int_ene: EnergyInfo\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamAnalysisInfo.slab","title":"slab  <code>instance-attribute</code>","text":"<pre><code>slab: EnergyInfo\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamOutput","title":"SkzcamOutput","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamOutput.adsorbate_slab_embedded_cluster","title":"adsorbate_slab_embedded_cluster  <code>instance-attribute</code>","text":"<pre><code>adsorbate_slab_embedded_cluster: Atoms\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamOutput.ecp_region_indices_set","title":"ecp_region_indices_set  <code>instance-attribute</code>","text":"<pre><code>ecp_region_indices_set: list[list[int]]\n</code></pre>"},{"location":"reference/autoSKZCAM/types.html#autoSKZCAM.types.SkzcamOutput.quantum_cluster_indices_set","title":"quantum_cluster_indices_set  <code>instance-attribute</code>","text":"<pre><code>quantum_cluster_indices_set: list[list[int]]\n</code></pre>"}]}