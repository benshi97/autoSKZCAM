from __future__ import annotations

from copy import deepcopy
from importlib.util import find_spec
from pathlib import Path
from typing import TYPE_CHECKING, Literal
import re

import numpy as np
from ase.atoms import Atoms
from ase.calculators.orca import ORCA, OrcaProfile
from ase.data import atomic_numbers
from ase.io import read, write
from ase.units import Bohr
from monty.dev import requires
from monty.io import zopen
from monty.os.path import zpath
from quacc import get_settings

from ase.io.orca import write_orca
from quacc.calculators.mrcc.io import write_mrcc
from quacc.calculators.mrcc.mrcc import MRCC, MrccProfile

from autoSKZCAM.data import (
    capped_ecp_defaults,
    code_calculation_defaults,
    frozen_core_defaults,
)
from autoSKZCAM.io import MRCCInputGenerator, ORCAInputGenerator

if TYPE_CHECKING:
    from numpy.typing import NDArray

    from autoSKZCAM.types import (
        CalculatorInfo,
        ElementInfo,
        ElementStr,
        ONIOMLayerInfo,
        SKZCAMOutput,
    )

has_chemshell = find_spec("chemsh") is not None


class autoSKZCAMPrepare:
    """
    From the set of ONIOM calculations, this class generates the calculations needed to be performed for each cluster from the series of clusters generated by the [quacc.atoms.skzcam.CreateSKZCAMClusters][] class.
    """

    def __init__(
        self,
        adsorbate_slab_embedded_cluster: Atoms,
        quantum_cluster_indices_set: list[list[int]],
        ecp_region_indices_set: list[list[int]],
        oniom_layers: dict[str, ONIOMLayerInfo],
        capped_ecp: dict[Literal["mrcc", "orca"], str] = capped_ecp_defaults,
        multiplicities: dict[str, int] | None = None,
    ) -> None:
        """
        Parameters
        ----------
        adsorbate_slab_embedded_cluster
            The ASE Atoms object containing the atomic coordinates and atomic charges from the .pun file, as well as the atom type. This object is created by the [quacc.atoms.skzcam.CreateSKZCAMClusters][] class.
        quantum_cluster_indices_set
            A list of lists containing the indices of the atoms of a set of quantum clusters. These indices are provided by the [quacc.atoms.skzcam.CreateSKZCAMClusters][] class.
        ecp_region_indices_set
            A list of lists containing the indices of the atoms in the ECP region of a set of quantum clusters. These indices are provided by the [quacc.atoms.skzcam.CreateSKZCAMClusters][] class.
        oniom_layers
            A dictionary containing the information for each of the calculations for each of the ONIOM layers. An arbitrary number of ONIOM layers can be included.
        capped_ecp
            A dictionary containing the capped ECPs for each element in the quantum cluster. The dictionary should be in the form of {code: "capped ecp info"}. The code should be either 'mrcc' or 'orca'. Refer to the [autoSKZCAM.data.capped_ecp_defaults][] for the default values and how it should be formatted.
        multiplicities
            A dictionary containing the multiplicities for the adsorbate, slab and adsorbate-slab complex. The dictionary should be in the form of {"adsorbate_slab": int, "adsorbate": int, "slab": int}.

        Returns
        -------
        None
        """

        if multiplicities is None:
            multiplicities = {"adsorbate_slab": 1, "adsorbate": 1, "slab": 1}
        self.adsorbate_slab_embedded_cluster = adsorbate_slab_embedded_cluster
        self.quantum_cluster_indices_set = quantum_cluster_indices_set
        self.ecp_region_indices_set = ecp_region_indices_set
        self.oniom_layers = oniom_layers
        self.capped_ecp = capped_ecp_defaults
        self.multiplicities = multiplicities

        # Check that the quantum_cluster_indices_set and ecp_region_indices_set are the same length
        if len(self.quantum_cluster_indices_set) != len(self.ecp_region_indices_set):
            raise ValueError(
                "The quantum_cluster_indices_set and ecp_region_indices_set must be the same length."
            )

        # Raise an error if the capped_ecp dictionary is not formatted correctly
        for key in capped_ecp:
            if key.lower() == "mrcc" or key.lower() == "orca":
                self.capped_ecp[key.lower()] = capped_ecp[key]
            else:
                raise ValueError(
                    "The keys in the capped_ecp dictionary must be either 'mrcc' or 'orca' in the corresponding code format."
                )

        # Raise an error if multiplicities is not formatted correctly
        for structure in ["adsorbate_slab", "adsorbate", "slab"]:
            if structure not in self.multiplicities:
                raise ValueError(
                    "The multiplicities must be provided for all three structures: adsorbate_slab, adsorbate, and slab."
                )

        # Check that all of the necessary keywords are included in each oniom layer
        max_cluster = 0
        for _,oniom_layer in self.oniom_layers.items():
            for level in ["ll", "hl"]:
                if oniom_layer[level] is not None:
                    oniom_layer_parameters = oniom_layer[level]
                    # Check that all the required parameters are provided
                    for parameter in [
                        "method",
                        "max_cluster_num",
                        "basis",
                        "frozen_core",
                        "code",
                    ]:
                        if parameter not in oniom_layer_parameters:
                            raise ValueError(
                                f"The {parameter} parameter must be provided for all ONIOM layers specified."
                            )
                    # Check that the maximum cluster number is below the number of quantum clusters for all ONIOM layers
                    if (
                        oniom_layer_parameters["max_cluster_num"]
                        > len(self.quantum_cluster_indices_set)
                        or oniom_layer_parameters["max_cluster_num"] < 1
                    ):
                        raise ValueError(
                            "The maximum cluster number for all ONIOM layers must be bigger than 0 and less than or equal to the number of quantum clusters generated by autoSKZCAM."
                        )
                    if oniom_layer_parameters["max_cluster_num"] > max_cluster:
                        max_cluster = oniom_layer_parameters["max_cluster_num"]

                    # Check that the frozencore is either 'valence' or 'semicore'
                    if oniom_layer_parameters["frozen_core"] not in [
                        "valence",
                        "semicore",
                    ]:
                        raise ValueError(
                            "The frozen_core must be specified as either 'valence' or 'semicore'."
                        )

                    # Check that the code is either 'mrcc' or 'orca'
                    if oniom_layer_parameters["code"] not in ["mrcc", "orca"]:
                        raise ValueError(
                            "The code must be specified as either 'mrcc' or 'orca'."
                        )

                    # Ensure that basis is specified as either DZ, TZ, QZ, 5Z or CBS(X/Y)
                    if oniom_layer_parameters["basis"] not in [
                        "DZ",
                        "TZ",
                        "QZ",
                        "5Z",
                        "CBS(DZ//TZ)",
                        "CBS(TZ//QZ)",
                        "CBS(QZ//5Z)",
                    ]:
                        raise ValueError(
                            "The basis must be specified as either DZ, TZ, QZ, 5Z, CBS(DZ//TZ), CBS(TZ//QZ) or CBS(QZ//5Z)."
                        )

                    # Some checks of the element_info in the case where the layer involves a CBS calculation
                    # If element_info is provided, check that it is a dictionary
                    if (
                        "element_info" in oniom_layer_parameters
                        and oniom_layer_parameters["element_info"] is not None
                    ):
                        # Check that the keys in element_info are valid element symbols
                        if not all(
                            key in frozen_core_defaults["semicore"]
                            for key in oniom_layer_parameters["element_info"]
                        ):
                            raise ValueError(
                                "The keys in the element_info dictionary must be valid element symbols."
                            )
                        # If the basis set is a CBS basis set, ensure that the basis set is split into two
                        if _is_valid_cbs_format(oniom_layer_parameters["basis"])[0]:
                            for element in oniom_layer_parameters["element_info"]:
                                for basis_type in [
                                    "basis",
                                    "ri_scf_basis",
                                    "ri_cwft_basis",
                                ]:
                                    if (
                                        basis_type
                                        in oniom_layer_parameters["element_info"][
                                            element
                                        ]
                                        and not _is_valid_cbs_format(oniom_layer_parameters["element_info"][
                                            element
                                        ][basis_type])[0]
                                    ):
                                        raise ValueError(
                                            f"The {basis_type} parameter must be provided in the element_info dictionary as format CBS(X//Y), where X and Y are the two basis sets."
                                        )

                    # If code_inputs is provided and the code is orca, check that the orcasimpleinput and orcablocks are provided
                    if (
                        oniom_layer_parameters["code"] == "orca"
                        and "code_inputs" in oniom_layer_parameters
                        and oniom_layer_parameters["code_inputs"] is not None
                    ):
                        for key in oniom_layer_parameters["code_inputs"]:
                            if key not in ["orcasimpleinput", "orcablocks"]:
                                raise ValueError(
                                    "If the code is orca, the code_inputs dictionary can only contain the orcasimpleinput and orcablocks keys."
                                )

        self.max_cluster = max_cluster

    def initialize_calculator(
        self,
        oniom_layer_parameters: ONIOMLayerInfo,
        quantum_cluster_indices: list[int],
        ecp_region_indices: list[int],
        element_info: dict[ElementStr, ElementInfo],
    ) -> CalculatorInfo:
        """
        Initialize the ASE calculator for the quantum cluster with the necessary inputs.

        Parameters
        ----------
        code
            The code to use for the quantum cluster. This could be either mrcc or orca.
        quantum_cluster_indices
            The indices of the atoms in the quantum cluster.
        ecp_region_indices
            The indices of the atoms in the ECP region.
        element_info
            A dictionary with elements as keys which gives the (1) number of core electrons as 'core', (2) basis set as 'basis', (3) effective core potential as 'ecp', (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as 'ri_scf_basis' and (5) resolution-of-identity/density-fitting for correlated wave-function methods as 'ri_cwft_basis'.

        Returns
        -------
        CalculatorInfo
            A dictionary containing the ASE Atoms object for the 'adsorbate', 'slab' and 'adsorbate_slab' structures, and the ASE calculator for each structure.
        """
        code = oniom_layer_parameters["code"]
        method = oniom_layer_parameters["method"]
        calculators = {
            structure: deepcopy(self.adsorbate_slab_embedded_cluster)
            for structure in ["adsorbate", "slab", "adsorbate_slab"]
        }

        # Depending on the code, set the calculator and inputs
        if code == "mrcc":
            # Use MRCCInputGenerator to generate the necessary blocks for the SKZCAM protocol for the MRCC ASE calculator
            mrcc_skzcam_inputs = MRCCInputGenerator(
                adsorbate_slab_embedded_cluster=self.adsorbate_slab_embedded_cluster,
                quantum_cluster_indices=quantum_cluster_indices,
                ecp_region_indices=ecp_region_indices,
                element_info=element_info,
                include_cp=True,
                multiplicities=self.multiplicities,
            ).generate_input()

            if method.upper() == "LNO-CCSD(T)":
                mrcc_default_method_inputs = code_calculation_defaults[code][
                    "LNO-CCSD(T)"
                ]
            elif method.upper() in ["MP2", "RI-MP2"]:
                mrcc_default_method_inputs = code_calculation_defaults[code]["MP2"]
            else:
                mrcc_default_method_inputs = code_calculation_defaults[code]["Other"]

            # Add default values to the mrcc_calc_inputs dictionary
            if (
                "code_inputs" in oniom_layer_parameters
                and oniom_layer_parameters["code_inputs"] is not None
            ):
                mrcc_calc_inputs = {
                    **mrcc_default_method_inputs,
                    **oniom_layer_parameters["code_inputs"],
                }
            else:
                mrcc_calc_inputs = {**mrcc_default_method_inputs}

            # Combine with the mrcc_block inputs
            inputs = {
                structure: {**mrcc_calc_inputs, **mrcc_skzcam_inputs[structure]}
                for structure in mrcc_skzcam_inputs
            }

            for structure, calculator in calculators.items():
                calculator.calc = MRCC(
                    profile=MrccProfile(command=get_settings().MRCC_CMD),
                    **inputs[structure],
                )

        elif code == "orca":
            # Use ORCAInputGenerator to generate the necessary orca_blocks for the ORCA ASE calculator
            orca_skzcam_inputs = ORCAInputGenerator(
                adsorbate_slab_embedded_cluster=self.adsorbate_slab_embedded_cluster,
                quantum_cluster_indices=quantum_cluster_indices,
                ecp_region_indices=ecp_region_indices,
                element_info=element_info,
                include_cp=True,
                multiplicities=self.multiplicities,
            ).generate_input()

            if method.upper() == "DLPNO-CCSD(T)":
                orcasimpleinput = code_calculation_defaults[code]["orcasimpleinput"][
                    "DLPNO-CCSD(T)"
                ]
            elif method.upper() == "DLPNO-MP2":
                orcasimpleinput = code_calculation_defaults[code]["orcasimpleinput"][
                    "DLPNO-MP2"
                ]
            elif method.upper() in ["MP2", "RI-MP2"]:
                orcasimpleinput = code_calculation_defaults[code]["orcasimpleinput"][
                    "MP2"
                ]
            else:
                orcasimpleinput = code_calculation_defaults[code]["orcasimpleinput"][
                    "Other"
                ]

            orcablocks = code_calculation_defaults[code]["orcablocks"]

            if (
                "code_inputs" in oniom_layer_parameters
                and oniom_layer_parameters["code_inputs"] is not None
            ):
                if "orcasimpleinput" in oniom_layer_parameters["code_inputs"]:
                    orcasimpleinput = oniom_layer_parameters["code_inputs"][
                        "orcasimpleinput"
                    ]
                if "orcablocks" in oniom_layer_parameters["code_inputs"]:
                    orcablocks = oniom_layer_parameters["code_inputs"]["orcablocks"]

            # Add simpleinput and blocks to the orca_inputs dictionary
            inputs = {
                structure: {
                    "orcasimpleinput": orcasimpleinput,
                    "orcablocks": f"{orcablocks}\n{orca_skzcam_inputs[structure]}",
                }
                for structure in orca_skzcam_inputs
            }

            calculators = {
                structure: deepcopy(self.adsorbate_slab_embedded_cluster)
                for structure in inputs
            }
            for structure, calculator in calculators.items():
                calculator.calc = ORCA(
                    profile=OrcaProfile(command=get_settings().ORCA_CMD),
                    **inputs[structure],
                )

        return calculators

    def create_cluster_calcs(self) -> CalculatorInfo:
        """
        Create the set of calculations needed to be performed for each cluster from the series of clusters generated by the [quacc.atoms.skzcam.CreateSKZCAMClusters][] class.

        Returns
        -------
        dict[int, dict]
            A dictionary containing the information for each cluster. The information includes the indices of the atoms in the cluster, the indices of the atoms in the ECP region, the calculations to be performed, and the code specific kwargs for each calculation.

        """
        # Set up the dictionary to store the information for each cluster
        skzcam_cluster_calculators = {
            cluster_num: {} for cluster_num in range(1, self.max_cluster + 1)
        }
        for _, oniom_layer in self.oniom_layers.items():
            for level in ["ll", "hl"]:
                if oniom_layer[level] is not None:
                    oniom_layer_parameters = oniom_layer[level]
                    frozen_core = oniom_layer_parameters["frozen_core"]
                    method = oniom_layer_parameters["method"].replace(" ", "_")
                    code = oniom_layer_parameters["code"].lower()
                    (is_cbs, basis_1, basis_2) = _is_valid_cbs_format(oniom_layer_parameters["basis"])
                    if is_cbs:
                        (_, basis_1, basis_2) = _is_valid_cbs_format(oniom_layer_parameters["basis"])
                        basis_sets = [
                            basis_1,
                            basis_2,
                        ]
                    else:
                        basis_sets = [oniom_layer_parameters["basis"]]
                    for basis_idx, basis_set in enumerate(basis_sets):
                        default_element_info = self.create_element_info(
                            frozen_core=frozen_core, basis=basis_set, code=code
                        )
                        if 'element_info' in oniom_layer_parameters and oniom_layer_parameters['element_info'] is not None:
                            custom_element_info = {}
                            for key, value in oniom_layer_parameters["element_info"].items():
                                custom_element_info[key] = {}
                                for subkey, subvalue in value.items():
                                    if "basis" in subkey:
                                        is_element_basis_cbs = _is_valid_cbs_format(subvalue)
                                        if is_cbs and is_element_basis_cbs[0]:
                                            custom_element_info[key][subkey] = is_element_basis_cbs[basis_idx+1]
                                        else:
                                            custom_element_info[key][subkey] = subvalue
                                    else:
                                        custom_element_info[key][subkey] = subvalue

                            element_info = {
                                **default_element_info,
                                **custom_element_info,
                            }
                        else:
                            element_info = default_element_info

                        calculation_label = f"{code} {method} {frozen_core} {basis_set}"
                        for (
                            cluster_num,
                            cluster_calculators,
                        ) in skzcam_cluster_calculators.items():
                            if (
                                calculation_label not in cluster_calculators
                                and cluster_num
                                < oniom_layer_parameters["max_cluster_num"] + 1
                            ):
                                skzcam_cluster_calculators[cluster_num][
                                    calculation_label
                                ] = self.initialize_calculator(
                                    oniom_layer_parameters=oniom_layer_parameters,
                                    quantum_cluster_indices=self.quantum_cluster_indices_set[
                                        cluster_num - 1
                                    ],
                                    ecp_region_indices=self.ecp_region_indices_set[
                                        cluster_num - 1
                                    ],
                                    element_info=element_info,
                                )

        return skzcam_cluster_calculators

    def create_element_info(
        self,
        frozen_core: Literal["valence", "semicore"],
        basis: Literal["DZ", "TZ", "QZ", "5Z"],
        code: Literal["mrcc", "orca"],
        ecp: dict[ElementStr, str] | None = None,
    ) -> dict[ElementStr, ElementInfo]:
        """
        Creates the element info dictionary for the SKZCAM input across each oniom layer.

        Parameters
        ----------
        frozencore
            The frozen core to use for the quantum cluster. This could be specified as a string being either 'semicore' or 'valence'.
        basis
            The basis set to use for the quantum cluster. This could be either double-zeta, triple-zeta, quadruple-zeta, quintuple-zeta, denoted as 'DZ', 'TZ',' QZ' and '5Z' respectively.
        code
            The code to use for the quantum cluster. This could be either mrcc or orca.
        ecp
            The effective core potential to use for each element within the quantum cluster.
        ri_scf_basis
            The resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations.
        ri_cwft_basis
            The resolution-of-identity/density-fitting for correlated wave-function methods.

        Returns
        -------
        dict[ElementStr, ElementInfo]
            A dictionary with elements as keys which gives the (1) number of core electrons as 'core', (2) basis set as 'basis', (3) effective core potential as 'ecp', (4) resolution-of-identity/density-fitting auxiliary basis set for DFT/HF calculations as 'ri_scf_basis' and (5) resolution-of-identity/density-fitting for correlated wave-function methods as 'ri_cwft_basis'.
        """

        # Create an adsorbate_slab_quantum_cluster object for the first SKZCAM cluster
        adsorbate_slab_quantum_cluster = self.adsorbate_slab_embedded_cluster[
            self.quantum_cluster_indices_set[0]
        ]

        element_info_dict = {}
        # If use_presets is True, use some preset inputs based on basis set and frozen core
        for atom_idx, atom in enumerate(adsorbate_slab_quantum_cluster):
            if atom.symbol in element_info_dict:
                continue
            if adsorbate_slab_quantum_cluster.get_array("atom_type")[atom_idx] in [
                "adsorbate",
                "anion",
            ]:
                element_info_dict[atom.symbol] = {
                    "core": frozen_core_defaults["valence"][atom.symbol],
                    "basis": f"aug-cc-pV{basis}",
                    "ecp": None if ecp is None else ecp.get(atom.symbol, None),
                    "ri_scf_basis": "def2-QZVPP-RI-JK" if code == "mrcc" else "def2/J",
                    "ri_cwft_basis": f"aug-cc-pV{basis}-RI"
                    if code == "mrcc"
                    else f"aug-cc-pV{basis}/C",
                }
            elif (
                adsorbate_slab_quantum_cluster.get_array("atom_type")[atom_idx]
                == "cation"
                and frozen_core == "valence"
            ):
                element_info_dict[atom.symbol] = {
                    "core": frozen_core_defaults["valence"][atom.symbol],
                    "basis": f"cc-pV{basis}",
                    "ecp": None if ecp is None else ecp.get(atom.symbol, None),
                    "ri_scf_basis": "def2-QZVPP-RI-JK" if code == "mrcc" else "def2/J",
                    "ri_cwft_basis": f"cc-pV{basis}-RI"
                    if code == "mrcc"
                    else f"cc-pV{basis}/C",
                }
            elif (
                adsorbate_slab_quantum_cluster.get_array("atom_type")[atom_idx]
                == "cation"
                and frozen_core == "semicore"
            ):
                element_info_dict[atom.symbol] = {
                    "core": frozen_core_defaults["semicore"][atom.symbol],
                    "basis": f"cc-pwCV{basis}",
                    "ecp": None if ecp is None else ecp.get(atom.symbol, None),
                    "ri_scf_basis": "def2-QZVPP-RI-JK" if code == "mrcc" else "def2/J",
                    "ri_cwft_basis": f"cc-pwCV{basis}-RI"
                    if code == "mrcc"
                    else "AutoAux",
                }

        return element_info_dict
    
    def generate_input(
        self, skzcam_cluster_calculators: CalculatorInfo, input_dir: str | Path
    ) -> None:
        """
        Generates the SKZCAM input for the MRCC and ORCA ASE calculators.

        Parameters
        ----------
        input_dir
            The directory where the input files will be written.

        Returns
        -------
        None
        """

        for cluster_num in skzcam_cluster_calculators:
            for calculation_label in skzcam_cluster_calculators[cluster_num]:
                code = calculation_label.split()[0]
                method = calculation_label.split()[1]
                frozen_core = calculation_label.split()[2]
                basis_set = calculation_label.split()[3]
                if code == "mrcc":
                    # Write MRCC input files
                    for structure in ["adsorbate", "slab", "adsorbate_slab"]:
                        write_mrcc(
                            Path(
                                input_dir,
                                f"{code}_MINP_{method}_cluster_{cluster_num}_{basis_set}_{structure}",
                            ),
                            self.adsorbate_slab_embedded_cluster,
                            mrcc_inputs[structure],
                        )

                elif code == "orca":
                    element_info = self.create_element_info(
                        basis=basis_set,
                        frozen_core=frozen_core,
                        code=code,
                        ecp={"Mg": "Hellow"},
                    )
                    # Use ORCAInputGenerator to generate the necessary orca_blocks for the ORCA ASE calculator
                    orca_input_generator = ORCAInputGenerator(
                        adsorbate_slab_embedded_cluster=self.adsorbate_slab_embedded_cluster,
                        quantum_cluster_indices=skzcam_clusters_information_dict[
                            cluster_num
                        ]["quantum_cluster_indices"],
                        ecp_region_indices=skzcam_clusters_information_dict[
                            cluster_num
                        ]["ecp_region_indices"],
                        element_info=element_info,
                        include_cp=True,
                        multiplicities={"adsorbate_slab": 1, "adsorbate": 1, "slab": 1},
                    )
                    orca_blocks = orca_input_generator.generate_input()

                    # Add simpleinput and blocks to the orca_inputs dictionary
                    orca_inputs = {
                        structure: {
                            "orcasimpleinput": "TightSCF RI-MP2 RIJCOSX SlowConv DIIS",
                            "orcablocks": orca_blocks[structure],
                        }
                        for structure in orca_blocks
                    }

                    # Write ORCA input files
                    for structure in ["adsorbate", "slab", "adsorbate_slab"]:
                        write_orca(
                            Path(
                                input_dir,
                                f"ORCA_MP2_cluster_{cluster_num}_{basis_name}_{structure}.inp",
                            ),
                            self.adsorbate_slab_embedded_cluster,
                            orca_inputs[structure],
                        )
                        if structure in ["slab", "adsorbate_slab"]:
                            # Write point charge files
                            orca_input_generator.create_point_charge_file(
                                Path(
                                    input_dir,
                                    f"ORCA_MP2_cluster_{cluster_num}_{basis_name}.pc",
                                )
                            )

    def generate_cluster_Atoms(self, skzcam_clusters_information_dict):
        """
        Generate the ASE Atoms object for each cluster from the series of clusters generated by the [quacc.atoms.skzcam.CreateSKZCAMClusters][] class.

        Parameters
        ----------
        skzcam_clusters_information_dict
            A dictionary containing the information for each cluster. The information includes the indices of the atoms in the cluster, the indices of the atoms in the ECP region, the calculations to be performed, and the code specific kwargs for each calculation.

        Returns
        -------
        dict[int, dict]
            A dictionary containing the information for each cluster. The information includes the indices of the atoms in the cluster, the indices of the atoms in the ECP region, the calculations to be performed, and the code specific kwargs for each calculation. The dictionary also includes the ASE Atoms object for each cluster.
        """
        autoskzcam_clusters_atoms_data = {}
        for cluster_num in skzcam_clusters_information_dict:
            cluster_info = skzcam_clusters_information_dict[cluster_num]
            cluster_atoms = self.adsorbate_slab_embedded_cluster[
                cluster_info["cluster indices"]
            ]
            autoskzcam_clusters_atoms_data[cluster_num] = {
                **cluster_info,
                "cluster Atoms": cluster_atoms,
            }
        return {
            cluster_num: {
                **skzcam_clusters_information_dict[cluster_num],
                "cluster Atoms": self.adsorbate_slab_embedded_cluster[
                    skzcam_clusters_information_dict[cluster_num]["cluster indices"]
                ],
            }
            for cluster_num in skzcam_clusters_information_dict
        }


class CreateSKZCAMClusters:
    """
    A class to create the quantum clusters and ECP regions for the SKZCAM protocol.

    Attributes
    ----------
    adsorbate_indices
        The indices of the atoms that make up the adsorbate molecule.
    slab_center_indices
        The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.
    slab_indices
        The indices of the atoms that make up the slab.
    atom_oxi_states
        A dictionary with the element symbol as the key and its oxidation state as the value.
    adsorbate_slab_file
        The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.
    pun_file
        The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex. This file should be generated by ChemShell. If it is None, then ChemShell wil be used to create this file.
    adsorbate
        The ASE Atoms object containing the atomic coordinates of the adsorbate.
    slab
        The ASE Atoms object containing the atomic coordinates of the slab.
    adsorbate_slab
        The ASE Atoms object containing the atomic coordinates of the adsorbate-slab complex.
    adsorbate_slab_embedded_cluster
        The ASE Atoms object containing the atomic coordinates, atomic charges and atom type (i.e., point charge or cation/anion) from the .pun file for the embedded cluster of the adsorbate-slab complex.
    slab_embedded_cluster
        The ASE Atoms object containing the atomic coordinates, atomic charges and atom type (i.e., point charge or cation/anion) from the .pun file for the embedded cluster of the slab.
    quantum_cluster_indices_set
        A list of lists of indices of the atoms in the set of quantum clusters created by the SKZCAM protocol
    ecp_region_indices_set
        A list of lists of indices of the atoms in the ECP region for the set of quantum clusters created by the SKZCAM protocol
    """

    def __init__(
        self,
        adsorbate_indices: list[int],
        slab_center_indices: list[int],
        atom_oxi_states: dict[str, int],
        adsorbate_slab_file: str | Path | None = None,
        pun_file: str | Path | None = None,
    ) -> None:
        """
        Parameters
        ----------
        adsorbate_indices
            The indices of the atoms that make up the adsorbate molecule.
        slab_center_indices
            The indices of the atoms that make up the 'center' of the slab right beneath the adsorbate.
        atom_oxi_states
            A dictionary with the element symbol as the key and its oxidation state as the value.
        adsorbate_slab_file
            The path to the file containing the adsorbate molecule on the surface slab. It can be in any format that ASE can read.
        pun_file
            The path to the .pun file containing the atomic coordinates and charges of the adsorbate-slab complex. This file should be generated by ChemShell. If it is None, then ChemShell wil be used to create this file.

        Returns
        -------
        None
        """

        self.adsorbate_indices = adsorbate_indices
        self.slab_center_indices = slab_center_indices
        self.slab_indices = None  # This will be set later
        self.atom_oxi_states = atom_oxi_states
        self.adsorbate_slab_file = adsorbate_slab_file
        self.pun_file = pun_file

        # Check that the adsorbate_indices and slab_center_indices are not the same
        if any(x in self.adsorbate_indices for x in self.slab_center_indices):
            raise ValueError(
                "The adsorbate and slab center indices cannot be the same."
            )

        # Check that the adsorbate_slab_file and pun_file are not both None
        if self.adsorbate_slab_file is None and self.pun_file is None:
            raise ValueError(
                "Either the adsorbate_slab_file or pun_file must be provided."
            )

        # Initialize the adsorbate, slab and adsorbate_slab Atoms object which contains the adsorbate, slab and adsorbate-slab complex respectively
        self.adsorbate: Atoms | None
        self.slab: Atoms | None
        self.adsorbate_slab: Atoms | None

        # Initialize the embedded_adsorbate_slab_cluster, and embedded_slab_cluster Atoms object which are the embedded cluster for the adsorbate-slab complex and slab respectively
        self.adsorbate_slab_embedded_cluster: Atoms | None = None
        self.slab_embedded_cluster: Atoms | None = None

        # Initialize the quantum cluster indices and ECP region indices
        self.quantum_cluster_indices_set: list[list[int]] | None = None
        self.ecp_region_indices_set: list[list[int]] | None = None

    def convert_slab_to_atoms(self) -> None:
        """
        Read the file containing the periodic slab and adsorbate (geometry optimized) and format the resulting Atoms object to be used to create a .pun file in ChemShell.

        Returns
        -------
        None
        """

        # Get the necessary information for the cluster from a provided slab file (in any format that ASE can read)
        adsorbate_slab = read(self.adsorbate_slab_file)

        # Find indices (within adsorbate_slab) of the slab
        slab_indices = self.slab_center_indices + [
            i
            for i, _ in enumerate(adsorbate_slab)
            if i not in (self.adsorbate_indices + self.slab_center_indices)
        ]

        # Create adsorbate and slab from adsorbate_slab
        slab = adsorbate_slab[slab_indices]
        adsorbate = adsorbate_slab[self.adsorbate_indices]

        adsorbate.translate(-slab[0].position)
        slab.translate(-slab[0].position)

        # Get the relative distance of the adsorbate from the first center atom of the slab as defined in the slab_center_indices
        adsorbate_vector_from_slab = adsorbate[0].position - slab[0].position

        # Get the center of the cluster from the slab_center_indices
        slab_center_position = slab[
            : len(self.slab_center_indices)
        ].get_positions().sum(axis=0) / len(self.slab_center_indices)

        # Add the height of the adsorbate from the slab along the z-direction relative to the slab_center
        adsorbate_com_z_disp = (
            adsorbate.get_center_of_mass()[2] - slab_center_position[2]
        )

        center_position = (
            np.array([0.0, 0.0, adsorbate_com_z_disp]) + slab_center_position
        )

        self.adsorbate = adsorbate
        self.slab = slab
        self.adsorbate_slab = adsorbate_slab
        self.adsorbate_vector_from_slab = adsorbate_vector_from_slab
        self.center_position = center_position

    @requires(has_chemshell, "ChemShell is not installed")
    def run_chemshell(
        self,
        filepath: str | Path,
        chemsh_radius_active: float = 40.0,
        chemsh_radius_cluster: float = 60.0,
        chemsh_bq_layer: float = 6.0,
        write_xyz_file: bool = False,
    ) -> None:
        """
        Run ChemShell to create an embedded cluster from a slab.

        Parameters
        ----------
        filepath
            The location where the ChemShell output files will be written.
        chemsh_radius_active
            The radius of the active region in Angstroms. This 'active' region is simply region where the charge fitting is performed to ensure correct Madelung potential; it can be a relatively large value.
        chemsh_radius_cluster
            The radius of the total embedded cluster in Angstroms.
        chemsh_bq_layer
            The height above the surface to place some additional fitting point charges in Angstroms; simply for better reproduction of the electrostatic potential close to the adsorbate.
        write_xyz_file
            Whether to write an XYZ file of the cluster for visualisation.

        Returns
        -------
        None
        """
        from chemsh.io.tools import convert_atoms_to_frag

        # Convert ASE Atoms to ChemShell Fragment object
        slab_frag = convert_atoms_to_frag(self.slab, connect_mode="ionic", dim="2D")

        # Add the atomic charges to the fragment
        slab_frag.addCharges(self.atom_oxi_states)

        # Create the chemshell cluster (i.e., add electrostatic fitting charges) from the fragment
        chemsh_slab_embedded_cluster = slab_frag.construct_cluster(
            origin=0,
            radius_cluster=chemsh_radius_cluster / Bohr,
            radius_active=chemsh_radius_active / Bohr,
            bq_layer=chemsh_bq_layer / Bohr,
            adjust_charge="coordination_scaled",
        )

        # Save the final cluster to a .pun file
        chemsh_slab_embedded_cluster.save(
            filename=Path(filepath).with_suffix(".pun"), fmt="pun"
        )
        self.pun_file = Path(filepath).with_suffix(".pun")

        if write_xyz_file:
            # XYZ for visualisation
            chemsh_slab_embedded_cluster.save(
                filename=Path(filepath).with_suffix(".xyz"), fmt="xyz"
            )

    def run_skzcam(
        self,
        shell_max: int = 10,
        shell_width: float = 0.1,
        bond_dist: float = 2.5,
        ecp_dist: float = 6.0,
        write_clusters: bool = False,
        write_clusters_path: str | Path = ".",
        write_include_ecp: bool = False,
    ) -> SKZCAMOutput:
        """
        From a provided .pun file (generated by ChemShell), this function creates quantum clusters using the SKZCAM protocol. It will return the embedded cluster Atoms object and the indices of the atoms in the quantum clusters and the ECP region. The number of clusters created is controlled by the rdf_max parameter.

        Parameters
        ----------
        shell_max
            The maximum number of quantum clusters to be created.
        shell_width
            Defines the distance between atoms within shells; this is the maximum distance between any two atoms within the shell.
        bond_dist
            The distance within which an anion is considered to be coordinating a cation.
        ecp_dist
            The distance from edges of the quantum cluster to define the ECP region.
        write_clusters
            If True, the quantum clusters will be written to a file.
        write_clusters_path
            The path to the file where the quantum clusters will be written.
        write_include_ecp
            If True, the ECP region will be included in the quantum clusters.

        Returns
        -------
        dict[str, Atoms]
            A dictionary containing the embedded cluster Atoms object of the adsorbate-slab complex, accessed by the key 'adsorbate_slab_embedded_cluster', and the indices of the atoms in the quantum clusters and the ECP region, accessed by the keys 'quantum_cluster_indices_set' and 'ecp_region_indices_set' respectively.
        """

        # Read the .pun file and create the embedded_cluster Atoms object
        self.slab_embedded_cluster = self._convert_pun_to_atoms(pun_file=self.pun_file)

        # Get distances of all atoms from the cluster center
        atom_center_distances = _get_atom_distances(
            atoms=self.slab_embedded_cluster, center_position=self.center_position
        )

        # Determine the cation shells from the center of the embedded cluster
        _, cation_shells_idx = self._find_cation_shells(
            slab_embedded_cluster=self.slab_embedded_cluster,
            distances=atom_center_distances,
            shell_width=shell_width,
        )

        # Create the distance matrix for the embedded cluster
        slab_embedded_cluster_all_dist = self.slab_embedded_cluster.get_all_distances()

        # Create the anion coordination list for each cation shell
        anion_coord_idx = []
        for shell_idx in range(shell_max):
            shell_indices = cation_shells_idx[shell_idx]
            anion_coord_idx += [
                self._get_anion_coordination(
                    slab_embedded_cluster=self.slab_embedded_cluster,
                    cation_shell_indices=shell_indices,
                    dist_matrix=slab_embedded_cluster_all_dist,
                    bond_dist=bond_dist,
                )
            ]

        # Create the quantum clusters by summing up the indices of the cations and their coordinating anions
        slab_quantum_cluster_indices_set = []
        dummy_cation_indices = []
        dummy_anion_indices = []
        for shell_idx in range(shell_max):
            dummy_cation_indices += cation_shells_idx[shell_idx]
            dummy_anion_indices += anion_coord_idx[shell_idx]
            slab_quantum_cluster_indices_set += [
                list(set(dummy_cation_indices + dummy_anion_indices))
            ]

        # Get the ECP region for each quantum cluster
        slab_ecp_region_indices_set = self._get_ecp_region(
            slab_embedded_cluster=self.slab_embedded_cluster,
            quantum_cluster_indices_set=slab_quantum_cluster_indices_set,
            dist_matrix=slab_embedded_cluster_all_dist,
            ecp_dist=ecp_dist,
        )

        # Create the adsorbate_slab_embedded_cluster from slab_embedded_cluster and adsorbate atoms objects. This also sets the final quantum_cluster_indices_set and ecp_region_indices_set for the adsorbate_slab_embedded_cluster
        self._create_adsorbate_slab_embedded_cluster(
            quantum_cluster_indices_set=slab_quantum_cluster_indices_set,
            ecp_region_indices_set=slab_ecp_region_indices_set,
        )

        # Write the quantum clusters to files
        if write_clusters:
            for idx in range(len(self.quantum_cluster_indices_set)):
                quantum_atoms = self.adsorbate_slab_embedded_cluster[
                    self.quantum_cluster_indices_set[idx]
                ]
                if write_include_ecp:
                    ecp_atoms = self.adsorbate_slab_embedded_cluster[
                        self.ecp_region_indices_set[idx]
                    ]
                    ecp_atoms.set_chemical_symbols(np.array(["U"] * len(ecp_atoms)))
                    cluster_atoms = quantum_atoms + ecp_atoms
                else:
                    cluster_atoms = quantum_atoms
                write(
                    Path(write_clusters_path, f"SKZCAM_cluster_{idx}.xyz"),
                    cluster_atoms,
                )

        return {
            "adsorbate_slab_embedded_cluster": self.adsorbate_slab_embedded_cluster,
            "quantum_cluster_indices_set": self.quantum_cluster_indices_set,
            "ecp_region_indices_set": self.ecp_region_indices_set,
        }

    def _convert_pun_to_atoms(self, pun_file: str | Path) -> Atoms:
        """
        Reads a .pun file and returns an ASE Atoms object containing the atomic coordinates,
        point charges/oxidation states, and atom types.

        Parameters
        ----------
        pun_file
            The path to the .pun file created by ChemShell to be read.

        Returns
        -------
        Atoms
            The ASE Atoms object containing the atomic coordinates and atomic charges from the .pun file.
            The `oxi_states` array contains the atomic charges, and the `atom_type` array contains the
            atom types (cation, anion, neutral).
        """

        # Create a dictionary containing the atom types and whether they are cations or anions
        atom_type_dict = {
            atom: "cation" if oxi_state > 0 else "anion" if oxi_state < 0 else "neutral"
            for atom, oxi_state in self.atom_oxi_states.items()
        }

        # Load the pun file as a list of strings
        with zopen(zpath(str(Path(pun_file)))) as f:
            raw_pun_file = [
                line.rstrip().decode("utf-8")
                if isinstance(line, bytes)
                else line.rstrip()
                for line in f
            ]

        # Get the number of atoms and number of atomic charges in the .pun file
        n_atoms = int(raw_pun_file[3].split()[-1])
        n_charges = int(raw_pun_file[4 + n_atoms - 1 + 3].split()[-1])

        # Check if number of atom charges same as number of atom positions
        if n_atoms != n_charges:
            raise ValueError(
                "Number of atomic positions and atomic charges in the .pun file are not the same."
            )

        raw_atom_positions = raw_pun_file[4 : 4 + n_atoms]
        raw_charges = raw_pun_file[7 + n_atoms : 7 + 2 * n_atoms]
        charges = [float(charge) for charge in raw_charges]

        # Add the atomic positions the embedded_cluster Atoms object (converting from Bohr to Angstrom)
        atom_types = []
        atom_numbers = []
        atom_positions = []
        for _, line in enumerate(raw_atom_positions):
            line_info = line.split()

            # Add the atom type to the atom_type_list
            if line_info[0] in atom_type_dict:
                atom_types.append(atom_type_dict[line_info[0]])
            elif line_info[0] == "F":
                atom_types.append("pc")
            else:
                atom_types.append("unknown")

            # Add the atom number to the atom_number_list and position to the atom_position_list
            atom_numbers += [atomic_numbers[line_info[0]]]
            atom_positions += [
                [
                    float(line_info[1]) * Bohr,
                    float(line_info[2]) * Bohr,
                    float(line_info[3]) * Bohr,
                ]
            ]

        slab_embedded_cluster = Atoms(numbers=atom_numbers, positions=atom_positions)

        # Center the embedded cluster so that atom index 0 is at the [0, 0, 0] position
        slab_embedded_cluster.translate(-slab_embedded_cluster[0].position)

        # Add the `oxi_states` and `atom_type` arrays to the Atoms object
        slab_embedded_cluster.set_array("oxi_states", np.array(charges))
        slab_embedded_cluster.set_array("atom_type", np.array(atom_types))

        return slab_embedded_cluster

    def _create_adsorbate_slab_embedded_cluster(
        self,
        quantum_cluster_indices_set: list[list[int]] | None = None,
        ecp_region_indices_set: list[list[int]] | None = None,
    ) -> None:
        """
        Insert the adsorbate into the embedded cluster and update the quantum cluster and ECP region indices.

        Parameters
        ----------
        quantum_cluster_indices_set
            A list of lists containing the indices of the atoms in each quantum cluster.
        ecp_region_indices_set
            A list of lists containing the indices of the atoms in the ECP region for each quantum cluster.

        Returns
        -------
        None
        """

        # Remove PBC from the adsorbate
        self.adsorbate.set_pbc(False)

        # Translate the adsorbate to the correct position relative to the slab
        self.adsorbate.translate(
            self.slab_embedded_cluster[0].position
            - self.adsorbate[0].position
            + self.adsorbate_vector_from_slab
        )

        # Set oxi_state and atom_type arrays for the adsorbate
        self.adsorbate.set_array("oxi_states", np.array([0.0] * len(self.adsorbate)))
        self.adsorbate.set_array(
            "atom_type", np.array(["adsorbate"] * len(self.adsorbate))
        )

        # Add the adsorbate to the embedded cluster
        self.adsorbate_slab_embedded_cluster = (
            self.adsorbate + self.slab_embedded_cluster
        )

        # Update the quantum cluster and ECP region indices
        if quantum_cluster_indices_set is not None:
            quantum_cluster_indices_set = [
                list(range(len(self.adsorbate)))
                + [idx + len(self.adsorbate) for idx in cluster]
                for cluster in quantum_cluster_indices_set
            ]
        if ecp_region_indices_set is not None:
            ecp_region_indices_set = [
                [idx + len(self.adsorbate) for idx in cluster]
                for cluster in ecp_region_indices_set
            ]

        self.quantum_cluster_indices_set = quantum_cluster_indices_set
        self.ecp_region_indices_set = ecp_region_indices_set

    def _find_cation_shells(
        self, slab_embedded_cluster: Atoms, distances: NDArray, shell_width: float = 0.1
    ) -> tuple[list[list[int]], list[list[int]]]:
        """
        Returns a list of lists containing the indices of the cations in each shell, based on distance from the embedded cluster center.
        This is achieved by clustering the data based on the DBSCAN clustering algorithm.

        Parameters
        ----------
        slab_embedded_cluster
            The ASE Atoms object containing the atomic coordinates AND the atom types (i.e. cation or anion).
        distances
            The distance of atoms from the cluster center.
        shell_width
            Defines the distance between atoms within shells; this is the maximum distance between any two atoms within the shell

        Returns
        -------
        list[list[int]]
            A list of lists containing the distance of the cation in each shell from the adsorbate.
        list[list[int]]
            A list of lists containing the indices of the cations in each shell.
        """

        # Define the empty list to store the cation shells
        shells_distances = []
        shells_indices = []

        # Sort the points by distance from the cluster center for the cations only
        distances_sorted = []
        distances_sorted_indices = []
        for i in np.argsort(distances):
            if slab_embedded_cluster.get_array("atom_type")[i] == "cation":
                distances_sorted.append(distances[i])
                distances_sorted_indices.append(i)

        current_point = distances_sorted[0]
        current_shell = [current_point]
        current_shell_idx = [distances_sorted_indices[0]]

        for idx, point in enumerate(distances_sorted[1:]):
            if point <= current_point + shell_width:
                current_shell.append(point)
                current_shell_idx.append(distances_sorted_indices[idx + 1])
            else:
                shells_distances.append(current_shell)
                shells_indices.append(current_shell_idx)
                current_shell = [point]
                current_shell_idx = [distances_sorted_indices[idx + 1]]
            current_point = point
        shells_distances.append(current_shell)
        shells_indices.append(current_shell_idx)

        return shells_distances, shells_indices

    def _get_anion_coordination(
        self,
        slab_embedded_cluster: Atoms,
        cation_shell_indices: list[int],
        dist_matrix: NDArray,
        bond_dist: float = 2.5,
    ) -> list[int]:
        """
        Returns a list of lists containing the indices of the anions coordinating the cation indices provided.

        Parameters
        ----------
        slab_embedded_cluster
            The ASE Atoms object containing the atomic coordinates AND the atom types (i.e. cation or anion).
        cation_shell_indices
            A list of the indices of the cations in the cluster.
        dist_matrix
            A matrix containing the distances between each pair of atoms in the embedded cluster.
        bond_dist
            The distance within which an anion is considered to be coordinating a cation.

        Returns
        -------
        list[int]
            A list containing the indices of the anions coordinating the cation indices.
        """

        # Define the empty list to store the anion coordination
        anion_coord_indices = []

        # Iterate over the cation shell indices and find the atoms within the bond distance of each cation
        for atom_idx in cation_shell_indices:
            anion_coord_indices += [
                idx
                for idx, dist in enumerate(dist_matrix[atom_idx])
                if (
                    dist < bond_dist
                    and slab_embedded_cluster.get_array("atom_type")[idx] == "anion"
                )
            ]

        return list(set(anion_coord_indices))

    def _get_ecp_region(
        self,
        slab_embedded_cluster: Atoms,
        quantum_cluster_indices_set: list[int],
        dist_matrix: NDArray,
        ecp_dist: float = 6.0,
    ) -> list[list[int]]:
        """
        Returns a list of lists containing the indices of the atoms in the ECP region of the embedded cluster for each quantum cluster

        Parameters
        ----------
        slab_embedded_cluster
            The ASE Atoms object containing the atomic coordinates AND the atom types (i.e. cation or anion).
        quantum_cluster_indices_set
            A list of lists containing the indices of the atoms in each quantum cluster.
        dist_matrix
            A matrix containing the distances between each pair of atoms in the embedded cluster.
        ecp_dist
            The distance from edges of the quantum cluster to define the ECP region.

        Returns
        -------
        list[list[int]]
            A list of lists containing the indices of the atoms in the ECP region for each quantum cluster.
        """

        ecp_region_indices_set = []
        dummy_cation_indices = []

        # Iterate over the quantum clusters and find the atoms within the ECP distance of each quantum cluster
        for cluster in quantum_cluster_indices_set:
            dummy_cation_indices += cluster
            cluster_ecp_region_idx = []
            for atom_idx in dummy_cation_indices:
                for idx, dist in enumerate(dist_matrix[atom_idx]):
                    # Check if the atom is within the ecp_dist region and is not in the quantum cluster and is a cation
                    if (
                        dist < ecp_dist
                        and idx not in dummy_cation_indices
                        and slab_embedded_cluster.get_array("atom_type")[idx]
                        == "cation"
                    ):
                        cluster_ecp_region_idx += [idx]

            ecp_region_indices_set += [list(set(cluster_ecp_region_idx))]

        return ecp_region_indices_set


def _get_atom_distances(atoms: Atoms, center_position: NDArray) -> NDArray:
    """
    Returns the distance of all atoms from the center position of the embedded cluster

    Parameters
    ----------
    embedded_cluster
        The ASE Atoms object containing the atomic coordinates of the embedded cluster.
    center_position
        The position of the center of the embedded cluster (i.e., position of the adsorbate).

    Returns
    -------
    NDArray
        An array containing the distances of each atom in the Atoms object from the cluster center.
    """

    return np.array([np.linalg.norm(atom.position - center_position) for atom in atoms])

def _is_valid_cbs_format(string) -> list[bool, str | None, str | None]:
    """
    Returns True if the string is in the format of a CBS extrapolation when specified in element_info.

    Parameters
    ----------
    string
        The string to be checked.

    Returns
    -------
    bool
        True if the string is in the format of a CBS extrapolation, False otherwise.
    """
    string = string.replace(" ", "")
    # Define the regex pattern with capturing groups for the strings in between
    pattern = r"^CBS\((.+?)//(.+?)\)$"
    # Match the string against the pattern
    match = re.match(pattern, string)
    if match:
        # Return the captured groups as a tuple
        return True, match.group(1), match.group(2)
    return False, None, None